typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned long u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef long i32;
typedef long long i64;

#define STDCALL __stdcall
#define STDCALLP STDCALL*

#define win_PM_REMOVE 0x0001
#define win_WM_QUIT 0x0012
#define win_WM_DESTROY 0x0002
#define win_WM_KEYDOWN 0x0100
#define win_VK_ESCAPE 0x001b
#define win_VK_CONTROL 0x11
#define win_WS_OVERLAPPED 0x00000000L
#define win_WS_VISIBLE 0x10000000L
#define win_WS_CAPTION 0x00C00000L
#define win_WS_SYSMENU 0x00080000L
#define win_WS_MINIMIZEBOX 0x00020000L
#define win_CW_USEDEFAULT ((u32)0x80000000)
#define win_INFINITE 0xFFFFFFFF
#define win_STANDARD_RIGHTS_REQUIRED 0x000F0000L
#define win_SYNCHRONIZE 0x00100000L
#define win_EVENT_ALL_ACCESS (win_STANDARD_RIGHTS_REQUIRED|win_SYNCHRONIZE|0x3)
#define win_MEM_COMMIT 0x1000
#define win_MEM_RESERVE 0x2000
#define win_MEM_RELEASE 0x8000
#define win_PAGE_READWRITE 0x04
#define win_MAKEINTRESOURCE(i) ((char*)((u64)((u16)(i))))
#define win_IDC_ARROW win_MAKEINTRESOURCE(32512)
#define win_GENERIC_READ 0x80000000
#define win_OPEN_EXISTING 3

// TODO: Improve assert implementation
#ifdef _DEBUG
#define Assert(Expression) if (!(Expression)) { __debugbreak(); }
#else
#define Assert(Expression)
#endif

struct win_POINT {
    i32 x;
    i32 y;
};
struct win_MSG {
    void* hwnd;
    u32 message;
    u64 wParam;
    i64 lParam;
    u32 time;
    win_POINT pt;
};
struct win_WNDCLASS {
    u32 style;
    void* lpfnWndProc;
    i32 cbClsExtra;
    i32 cbWndExtra;
    void* hInstance;
    void* hIcon;
    void* hCursor;
    void* hbrBackground;
    const char* lpszMenuName;
    const char* lpszClassName;
};
struct win_RECT {
    i32 left;
    i32 top;
    i32 right;
    i32 bottom;
};
struct win_GUID {
    u32 Data1;
    u16 Data2;
    u16 Data3;
    u8 Data4[8];
};
struct win_SECURITY_ATTRIBUTES {
    u32 nLength;
    void* lpSecurityDescriptor;
    i32 bInheritHandle;
};

#define D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES 0xffffffff
#define D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(Src0,Src1,Src2,Src3) (((Src0)&0x7)|(((Src1)&0x7)<<3)|(((Src2)&0x7)<<(3*2))|(((Src3)&0x7)<<(3*3))|(1<<(3*4)))
#define D3D12_DECODE_SHADER_4_COMPONENT_MAPPING(ComponentToExtract,Mapping) ((D3D12_SHADER_COMPONENT_MAPPING)(Mapping>>(3*ComponentToExtract)&0x7))
#define D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING D3D12_ENCODE_SHADER_4_COMPONENT_MAPPING(0,1,2,3)
#define D3D12_ENCODE_BASIC_FILTER(min,mag,mip,reduction) ((D3D12_FILTER)((((min)&0x3)<<4)|(((mag)&0x3)<<2)|((mip)&0x3)|(((reduction)&0x3)<<7)))
#define D3D12_ENCODE_ANISOTROPIC_FILTER(reduction) ((D3D12_FILTER)(0x40|D3D12_ENCODE_BASIC_FILTER(D3D12_FILTER_TYPE_LINEAR,D3D12_FILTER_TYPE_LINEAR,D3D12_FILTER_TYPE_LINEAR,reduction)))
#define D3D12_DECODE_MIN_FILTER(D3D12Filter) ((D3D12_FILTER_TYPE)(((D3D12Filter)>>4)&0x3))
#define D3D12_DECODE_MAG_FILTER(D3D12Filter) ((D3D12_FILTER_TYPE)(((D3D12Filter)>>2)&0x3))
#define D3D12_DECODE_MIP_FILTER(D3D12Filter) ((D3D12_FILTER_TYPE)(((D3D12Filter)>>0)&0x3))
#define D3D12_DECODE_FILTER_REDUCTION(D3D12Filter) ((D3D12_FILTER_REDUCTION_TYPE)(((D3D12Filter)>>7)&0x3))
#define D3D12_DECODE_IS_COMPARISON_FILTER(D3D12Filter) (D3D12_DECODE_FILTER_REDUCTION(D3D12Filter)==D3D12_FILTER_REDUCTION_TYPE_COMPARISON)
#define D3D12_DECODE_IS_ANISOTROPIC_FILTER(D3D12Filter) (((D3D12Filter)&0x40)&&(D3D12_FILTER_TYPE_LINEAR==D3D12_DECODE_MIN_FILTER(D3D12Filter))&&(D3D12_FILTER_TYPE_LINEAR==D3D12_DECODE_MAG_FILTER(D3D12Filter))&&(D3D12_FILTER_TYPE_LINEAR==D3D12_DECODE_MIP_FILTER(D3D12Filter)))

struct IUnknown;
struct ID3DBlob;
struct ID3D12Object;
struct ID3D12DeviceChild;
struct ID3D12RootSignature;
struct ID3D12Pageable;
struct ID3D12Heap;
struct ID3D12Resource;
struct ID3D12CommandAllocator;
struct ID3D12Fence;
struct ID3D12PipelineState;
struct ID3D12DescriptorHeap;
struct ID3D12QueryHeap;
struct ID3D12CommandSignature;
struct ID3D12CommandList;
struct ID3D12GraphicsCommandList;
struct ID3D12CommandQueue;
struct ID3D12Device;
struct ID3D12Debug;
struct IDXGIOutput;
struct IDXGIAdapter;
struct IDXGIAdapter1;
struct IDXGISwapChain;
struct IDXGISwapChain1;
struct IDXGISwapChain3;
struct IDXGIFactory4;

typedef u64 D3D12_GPU_VIRTUAL_ADDRESS;
typedef win_RECT D3D12_RECT;

enum DXGI_FORMAT {
    DXGI_FORMAT_UNKNOWN = 0,
    DXGI_FORMAT_R32G32B32A32_TYPELESS = 1,
    DXGI_FORMAT_R32G32B32A32_FLOAT = 2,
    DXGI_FORMAT_R32G32B32A32_UINT = 3,
    DXGI_FORMAT_R32G32B32A32_SINT = 4,
    DXGI_FORMAT_R32G32B32_TYPELESS = 5,
    DXGI_FORMAT_R32G32B32_FLOAT = 6,
    DXGI_FORMAT_R32G32B32_UINT = 7,
    DXGI_FORMAT_R32G32B32_SINT = 8,
    DXGI_FORMAT_R16G16B16A16_TYPELESS = 9,
    DXGI_FORMAT_R16G16B16A16_FLOAT = 10,
    DXGI_FORMAT_R16G16B16A16_UNORM = 11,
    DXGI_FORMAT_R16G16B16A16_UINT = 12,
    DXGI_FORMAT_R16G16B16A16_SNORM = 13,
    DXGI_FORMAT_R16G16B16A16_SINT = 14,
    DXGI_FORMAT_R32G32_TYPELESS = 15,
    DXGI_FORMAT_R32G32_FLOAT = 16,
    DXGI_FORMAT_R32G32_UINT = 17,
    DXGI_FORMAT_R32G32_SINT = 18,
    DXGI_FORMAT_R32G8X24_TYPELESS = 19,
    DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20,
    DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21,
    DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22,
    DXGI_FORMAT_R10G10B10A2_TYPELESS = 23,
    DXGI_FORMAT_R10G10B10A2_UNORM = 24,
    DXGI_FORMAT_R10G10B10A2_UINT = 25,
    DXGI_FORMAT_R11G11B10_FLOAT = 26,
    DXGI_FORMAT_R8G8B8A8_TYPELESS = 27,
    DXGI_FORMAT_R8G8B8A8_UNORM = 28,
    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29,
    DXGI_FORMAT_R8G8B8A8_UINT = 30,
    DXGI_FORMAT_R8G8B8A8_SNORM = 31,
    DXGI_FORMAT_R8G8B8A8_SINT = 32,
    DXGI_FORMAT_R16G16_TYPELESS = 33,
    DXGI_FORMAT_R16G16_FLOAT = 34,
    DXGI_FORMAT_R16G16_UNORM = 35,
    DXGI_FORMAT_R16G16_UINT = 36,
    DXGI_FORMAT_R16G16_SNORM = 37,
    DXGI_FORMAT_R16G16_SINT = 38,
    DXGI_FORMAT_R32_TYPELESS = 39,
    DXGI_FORMAT_D32_FLOAT = 40,
    DXGI_FORMAT_R32_FLOAT = 41,
    DXGI_FORMAT_R32_UINT = 42,
    DXGI_FORMAT_R32_SINT = 43,
    DXGI_FORMAT_R24G8_TYPELESS = 44,
    DXGI_FORMAT_D24_UNORM_S8_UINT = 45,
    DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46,
    DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47,
    DXGI_FORMAT_R8G8_TYPELESS = 48,
    DXGI_FORMAT_R8G8_UNORM = 49,
    DXGI_FORMAT_R8G8_UINT = 50,
    DXGI_FORMAT_R8G8_SNORM = 51,
    DXGI_FORMAT_R8G8_SINT = 52,
    DXGI_FORMAT_R16_TYPELESS = 53,
    DXGI_FORMAT_R16_FLOAT = 54,
    DXGI_FORMAT_D16_UNORM = 55,
    DXGI_FORMAT_R16_UNORM = 56,
    DXGI_FORMAT_R16_UINT = 57,
    DXGI_FORMAT_R16_SNORM = 58,
    DXGI_FORMAT_R16_SINT = 59,
    DXGI_FORMAT_R8_TYPELESS = 60,
    DXGI_FORMAT_R8_UNORM = 61,
    DXGI_FORMAT_R8_UINT = 62,
    DXGI_FORMAT_R8_SNORM = 63,
    DXGI_FORMAT_R8_SINT = 64,
    DXGI_FORMAT_A8_UNORM = 65,
    DXGI_FORMAT_R1_UNORM = 66,
    DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67,
    DXGI_FORMAT_R8G8_B8G8_UNORM = 68,
    DXGI_FORMAT_G8R8_G8B8_UNORM = 69,
    DXGI_FORMAT_BC1_TYPELESS = 70,
    DXGI_FORMAT_BC1_UNORM = 71,
    DXGI_FORMAT_BC1_UNORM_SRGB = 72,
    DXGI_FORMAT_BC2_TYPELESS = 73,
    DXGI_FORMAT_BC2_UNORM = 74,
    DXGI_FORMAT_BC2_UNORM_SRGB = 75,
    DXGI_FORMAT_BC3_TYPELESS = 76,
    DXGI_FORMAT_BC3_UNORM = 77,
    DXGI_FORMAT_BC3_UNORM_SRGB = 78,
    DXGI_FORMAT_BC4_TYPELESS = 79,
    DXGI_FORMAT_BC4_UNORM = 80,
    DXGI_FORMAT_BC4_SNORM = 81,
    DXGI_FORMAT_BC5_TYPELESS = 82,
    DXGI_FORMAT_BC5_UNORM = 83,
    DXGI_FORMAT_BC5_SNORM = 84,
    DXGI_FORMAT_B5G6R5_UNORM = 85,
    DXGI_FORMAT_B5G5R5A1_UNORM = 86,
    DXGI_FORMAT_B8G8R8A8_UNORM = 87,
    DXGI_FORMAT_B8G8R8X8_UNORM = 88,
    DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89,
    DXGI_FORMAT_B8G8R8A8_TYPELESS = 90,
    DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91,
    DXGI_FORMAT_B8G8R8X8_TYPELESS = 92,
    DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93,
    DXGI_FORMAT_BC6H_TYPELESS = 94,
    DXGI_FORMAT_BC6H_UF16 = 95,
    DXGI_FORMAT_BC6H_SF16 = 96,
    DXGI_FORMAT_BC7_TYPELESS = 97,
    DXGI_FORMAT_BC7_UNORM = 98,
    DXGI_FORMAT_BC7_UNORM_SRGB = 99,
    DXGI_FORMAT_AYUV = 100,
    DXGI_FORMAT_Y410 = 101,
    DXGI_FORMAT_Y416 = 102,
    DXGI_FORMAT_NV12 = 103,
    DXGI_FORMAT_P010 = 104,
    DXGI_FORMAT_P016 = 105,
    DXGI_FORMAT_420_OPAQUE = 106,
    DXGI_FORMAT_YUY2 = 107,
    DXGI_FORMAT_Y210 = 108,
    DXGI_FORMAT_Y216 = 109,
    DXGI_FORMAT_NV11 = 110,
    DXGI_FORMAT_AI44 = 111,
    DXGI_FORMAT_IA44 = 112,
    DXGI_FORMAT_P8 = 113,
    DXGI_FORMAT_A8P8 = 114,
    DXGI_FORMAT_B4G4R4A4_UNORM = 115,
    DXGI_FORMAT_P208 = 130,
    DXGI_FORMAT_V208 = 131,
    DXGI_FORMAT_V408 = 132,
    DXGI_FORMAT_FORCE_UINT = 0xffffffff
};
struct DXGI_SAMPLE_DESC {
    u32 Count;
    u32 Quality;
};
enum D3D12_HEAP_TYPE {
    D3D12_HEAP_TYPE_DEFAULT = 1,
    D3D12_HEAP_TYPE_UPLOAD = 2,
    D3D12_HEAP_TYPE_READBACK = 3,
    D3D12_HEAP_TYPE_CUSTOM = 4
};
enum D3D12_CPU_PAGE_PROPERTY {
    D3D12_CPU_PAGE_PROPERTY_UNKNOWN = 0,
    D3D12_CPU_PAGE_PROPERTY_NOT_AVAILABLE = 1,
    D3D12_CPU_PAGE_PROPERTY_WRITE_COMBINE = 2,
    D3D12_CPU_PAGE_PROPERTY_WRITE_BACK = 3
};
enum D3D12_MEMORY_POOL {
    D3D12_MEMORY_POOL_UNKNOWN = 0,
    D3D12_MEMORY_POOL_L0 = 1,
    D3D12_MEMORY_POOL_L1 = 2
};
struct D3D12_HEAP_PROPERTIES {
    D3D12_HEAP_TYPE Type;
    D3D12_CPU_PAGE_PROPERTY CPUPageProperty;
    D3D12_MEMORY_POOL MemoryPoolPreference;
    u32 CreationNodeMask;
    u32 VisibleNodeMask;
};
enum D3D12_HEAP_FLAGS {
    D3D12_HEAP_FLAG_NONE = 0,
    D3D12_HEAP_FLAG_SHARED = 0x1,
    D3D12_HEAP_FLAG_DENY_BUFFERS = 0x4,
    D3D12_HEAP_FLAG_ALLOW_DISPLAY = 0x8,
    D3D12_HEAP_FLAG_SHARED_CROSS_ADAPTER = 0x20,
    D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES = 0x40,
    D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES = 0x80,
    D3D12_HEAP_FLAG_HARDWARE_PROTECTED = 0x100,
    D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES = 0,
    D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS = 0xc0,
    D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES = 0x44,
    D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES = 0x84
};
struct D3D12_HEAP_DESC {
    u64 SizeInBytes;
    D3D12_HEAP_PROPERTIES Properties;
    u64 Alignment;
    D3D12_HEAP_FLAGS Flags;
};
struct D3D12_RANGE {
    u64 Begin;
    u64 End;
};
enum D3D12_RESOURCE_DIMENSION {
    D3D12_RESOURCE_DIMENSION_UNKNOWN = 0,
    D3D12_RESOURCE_DIMENSION_BUFFER = 1,
    D3D12_RESOURCE_DIMENSION_TEXTURE1D = 2,
    D3D12_RESOURCE_DIMENSION_TEXTURE2D = 3,
    D3D12_RESOURCE_DIMENSION_TEXTURE3D = 4
};
enum D3D12_TEXTURE_LAYOUT {
    D3D12_TEXTURE_LAYOUT_UNKNOWN = 0,
    D3D12_TEXTURE_LAYOUT_ROW_MAJOR = 1,
    D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE = 2,
    D3D12_TEXTURE_LAYOUT_64KB_STANDARD_SWIZZLE = 3
};
enum D3D12_RESOURCE_FLAGS {
    D3D12_RESOURCE_FLAG_NONE = 0,
    D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET = 0x1,
    D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL = 0x2,
    D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS = 0x4,
    D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE = 0x8,
    D3D12_RESOURCE_FLAG_ALLOW_CROSS_ADAPTER = 0x10,
    D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS = 0x20
};
struct D3D12_RESOURCE_DESC {
    D3D12_RESOURCE_DIMENSION Dimension;
    u64 Alignment;
    u64 Width;
    u32 Height;
    u16 DepthOrArraySize;
    u16 MipLevels;
    DXGI_FORMAT Format;
    DXGI_SAMPLE_DESC SampleDesc;
    D3D12_TEXTURE_LAYOUT Layout;
    D3D12_RESOURCE_FLAGS Flags;
};
struct D3D12_BOX {
    u32 left;
    u32 top;
    u32 front;
    u32 right;
    u32 bottom;
    u32 back;
};
enum D3D12_DESCRIPTOR_HEAP_TYPE {
    D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV = 0,
    D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER = (D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV + 1),
    D3D12_DESCRIPTOR_HEAP_TYPE_RTV = (D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER + 1),
    D3D12_DESCRIPTOR_HEAP_TYPE_DSV = (D3D12_DESCRIPTOR_HEAP_TYPE_RTV + 1),
    D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES = (D3D12_DESCRIPTOR_HEAP_TYPE_DSV + 1)
};
enum D3D12_DESCRIPTOR_HEAP_FLAGS {
    D3D12_DESCRIPTOR_HEAP_FLAG_NONE = 0,
    D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE = 0x1
};
struct D3D12_DESCRIPTOR_HEAP_DESC {
    D3D12_DESCRIPTOR_HEAP_TYPE Type;
    u32 NumDescriptors;
    D3D12_DESCRIPTOR_HEAP_FLAGS Flags;
    u32 NodeMask;
};
struct D3D12_CPU_DESCRIPTOR_HANDLE {
    u64 ptr;
};
struct D3D12_GPU_DESCRIPTOR_HANDLE {
    u64 ptr;
};
struct D3D12_DISCARD_REGION {
    u32 NumRects;
    const D3D12_RECT* pRects;
    u32 FirstSubresource;
    u32 NumSubresources;
};
enum D3D12_COMMAND_LIST_TYPE {
    D3D12_COMMAND_LIST_TYPE_DIRECT = 0,
    D3D12_COMMAND_LIST_TYPE_BUNDLE = 1,
    D3D12_COMMAND_LIST_TYPE_COMPUTE = 2,
    D3D12_COMMAND_LIST_TYPE_COPY = 3
};
struct D3D12_SUBRESOURCE_FOOTPRINT {
    DXGI_FORMAT Format;
    u32 Width;
    u32 Height;
    u32 Depth;
    u32 RowPitch;
};
struct D3D12_PLACED_SUBRESOURCE_FOOTPRINT {
    u64 Offset;
    D3D12_SUBRESOURCE_FOOTPRINT Footprint;
};
enum D3D12_TEXTURE_COPY_TYPE {
    D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX = 0,
    D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT = 1
};
struct D3D12_TEXTURE_COPY_LOCATION {
    ID3D12Resource* pResource;
    D3D12_TEXTURE_COPY_TYPE Type;
    union {
        D3D12_PLACED_SUBRESOURCE_FOOTPRINT PlacedFootprint;
        u32 SubresourceIndex;
    };
};
struct D3D12_TILED_RESOURCE_COORDINATE {
    u32 X;
    u32 Y;
    u32 Z;
    u32 Subresource;
};
struct D3D12_TILE_REGION_SIZE {
    u32 NumTiles;
    i32 UseBox;
    u32 Width;
    u16 Height;
    u16 Depth;
};
enum D3D12_TILE_RANGE_FLAGS {
    D3D12_TILE_RANGE_FLAG_NONE = 0,
    D3D12_TILE_RANGE_FLAG_NULL = 1,
    D3D12_TILE_RANGE_FLAG_SKIP = 2,
    D3D12_TILE_RANGE_FLAG_REUSE_SINGLE_TILE = 4
};
struct D3D12_SUBRESOURCE_TILING {
    u32 WidthInTiles;
    u16 HeightInTiles;
    u16 DepthInTiles;
    u32 StartTileIndexInOverallResource;
};
struct D3D12_TILE_SHAPE {
    u32 WidthInTexels;
    u32 HeightInTexels;
    u32 DepthInTexels;
};
enum D3D12_TILE_MAPPING_FLAGS {
    D3D12_TILE_MAPPING_FLAG_NONE = 0,
    D3D12_TILE_MAPPING_FLAG_NO_HAZARD = 0x1
};
enum D3D12_TILE_COPY_FLAGS {
    D3D12_TILE_COPY_FLAG_NONE = 0,
    D3D12_TILE_COPY_FLAG_NO_HAZARD = 0x1,
    D3D12_TILE_COPY_FLAG_LINEAR_BUFFER_TO_SWIZZLED_TILED_RESOURCE = 0x2,
    D3D12_TILE_COPY_FLAG_SWIZZLED_TILED_RESOURCE_TO_LINEAR_BUFFER = 0x4
};
enum D3D12_RESOURCE_STATES {
    D3D12_RESOURCE_STATE_COMMON = 0,
    D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER = 0x1,
    D3D12_RESOURCE_STATE_INDEX_BUFFER = 0x2,
    D3D12_RESOURCE_STATE_RENDER_TARGET = 0x4,
    D3D12_RESOURCE_STATE_UNORDERED_ACCESS = 0x8,
    D3D12_RESOURCE_STATE_DEPTH_WRITE = 0x10,
    D3D12_RESOURCE_STATE_DEPTH_READ = 0x20,
    D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE = 0x40,
    D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE = 0x80,
    D3D12_RESOURCE_STATE_STREAM_OUT = 0x100,
    D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT = 0x200,
    D3D12_RESOURCE_STATE_COPY_DEST = 0x400,
    D3D12_RESOURCE_STATE_COPY_SOURCE = 0x800,
    D3D12_RESOURCE_STATE_RESOLVE_DEST = 0x1000,
    D3D12_RESOURCE_STATE_RESOLVE_SOURCE = 0x2000,
    D3D12_RESOURCE_STATE_GENERIC_READ = (((((0x1|0x2)|0x40)|0x80)|0x200)|0x800),
    D3D12_RESOURCE_STATE_PRESENT = 0,
    D3D12_RESOURCE_STATE_PREDICATION = 0x200
};
enum D3D12_RESOURCE_BARRIER_TYPE {
    D3D12_RESOURCE_BARRIER_TYPE_TRANSITION = 0,
    D3D12_RESOURCE_BARRIER_TYPE_ALIASING = (D3D12_RESOURCE_BARRIER_TYPE_TRANSITION + 1),
    D3D12_RESOURCE_BARRIER_TYPE_UAV = (D3D12_RESOURCE_BARRIER_TYPE_ALIASING + 1)
};
struct D3D12_RESOURCE_TRANSITION_BARRIER {
    ID3D12Resource* pResource;
    u32 Subresource;
    D3D12_RESOURCE_STATES StateBefore;
    D3D12_RESOURCE_STATES StateAfter;
};
struct D3D12_RESOURCE_ALIASING_BARRIER {
    ID3D12Resource* pResourceBefore;
    ID3D12Resource* pResourceAfter;
};
struct D3D12_RESOURCE_UAV_BARRIER {
    ID3D12Resource* pResource;
};
enum D3D12_RESOURCE_BARRIER_FLAGS {
    D3D12_RESOURCE_BARRIER_FLAG_NONE = 0,
    D3D12_RESOURCE_BARRIER_FLAG_BEGIN_ONLY = 0x1,
    D3D12_RESOURCE_BARRIER_FLAG_END_ONLY = 0x2
};
struct D3D12_RESOURCE_BARRIER {
    D3D12_RESOURCE_BARRIER_TYPE Type;
    D3D12_RESOURCE_BARRIER_FLAGS Flags;
    union {
        D3D12_RESOURCE_TRANSITION_BARRIER Transition;
        D3D12_RESOURCE_ALIASING_BARRIER Aliasing;
        D3D12_RESOURCE_UAV_BARRIER UAV;
    };
};
enum D3D12_INPUT_CLASSIFICATION {
    D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA = 0,
    D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA = 1
};
struct D3D12_INPUT_ELEMENT_DESC {
    const char* SemanticName;
    u32 SemanticIndex;
    DXGI_FORMAT Format;
    u32 InputSlot;
    u32 AlignedByteOffset;
    D3D12_INPUT_CLASSIFICATION InputSlotClass;
    u32 InstanceDataStepRate;
};
enum D3D12_FILL_MODE {
    D3D12_FILL_MODE_WIREFRAME = 2,
    D3D12_FILL_MODE_SOLID = 3
};
enum D3D12_PRIMITIVE_TOPOLOGY {
    D3D_PRIMITIVE_TOPOLOGY_UNDEFINED = 0,
    D3D_PRIMITIVE_TOPOLOGY_POINTLIST = 1,
    D3D_PRIMITIVE_TOPOLOGY_LINELIST = 2,
    D3D_PRIMITIVE_TOPOLOGY_LINESTRIP = 3,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST = 4,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP = 5,
    D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ = 10,
    D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ = 11,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ = 12,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ = 13,
    D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST = 33,
    D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST = 34,
    D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST = 35,
    D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST = 36,
    D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST = 37,
    D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST = 38,
    D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST = 39,
    D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST = 40,
    D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST = 41,
    D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST = 42,
    D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST = 43,
    D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST = 44,
    D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST = 45,
    D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST = 46,
    D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST = 47,
    D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST = 48,
    D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST = 49,
    D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST = 50,
    D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST = 51,
    D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST = 52,
    D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST = 53,
    D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST = 54,
    D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST = 55,
    D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST = 56,
    D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST = 57,
    D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST = 58,
    D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST = 59,
    D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST = 60,
    D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST = 61,
    D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST = 62,
    D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST = 63,
    D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST = 64
};
enum D3D12_PRIMITIVE_TOPOLOGY_TYPE {
    D3D12_PRIMITIVE_TOPOLOGY_TYPE_UNDEFINED = 0,
    D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT = 1,
    D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE = 2,
    D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE = 3,
    D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH = 4
};
struct D3D12_SO_DECLARATION_ENTRY {
    u32 Stream;
    const char* SemanticName;
    u32 SemanticIndex;
    u8 StartComponent;
    u8 ComponentCount;
    u8 OutputSlot;
};
enum D3D12_CULL_MODE {
    D3D12_CULL_MODE_NONE = 1,
    D3D12_CULL_MODE_FRONT = 2,
    D3D12_CULL_MODE_BACK = 3
};
struct D3D12_VIEWPORT {
    float TopLeftX;
    float TopLeftY;
    float Width;
    float Height;
    float MinDepth;
    float MaxDepth;
};
enum D3D12_COMPARISON_FUNC {
    D3D12_COMPARISON_FUNC_NEVER = 1,
    D3D12_COMPARISON_FUNC_LESS = 2,
    D3D12_COMPARISON_FUNC_EQUAL = 3,
    D3D12_COMPARISON_FUNC_LESS_EQUAL = 4,
    D3D12_COMPARISON_FUNC_GREATER = 5,
    D3D12_COMPARISON_FUNC_NOT_EQUAL = 6,
    D3D12_COMPARISON_FUNC_GREATER_EQUAL = 7,
    D3D12_COMPARISON_FUNC_ALWAYS = 8
};
enum D3D12_DEPTH_WRITE_MASK {
    D3D12_DEPTH_WRITE_MASK_ZERO = 0,
    D3D12_DEPTH_WRITE_MASK_ALL = 1
};
enum D3D12_STENCIL_OP {
    D3D12_STENCIL_OP_KEEP = 1,
    D3D12_STENCIL_OP_ZERO = 2,
    D3D12_STENCIL_OP_REPLACE = 3,
    D3D12_STENCIL_OP_INCR_SAT = 4,
    D3D12_STENCIL_OP_DECR_SAT = 5,
    D3D12_STENCIL_OP_INVERT = 6,
    D3D12_STENCIL_OP_INCR = 7,
    D3D12_STENCIL_OP_DECR = 8
};
struct D3D12_DEPTH_STENCILOP_DESC {
    D3D12_STENCIL_OP StencilFailOp;
    D3D12_STENCIL_OP StencilDepthFailOp;
    D3D12_STENCIL_OP StencilPassOp;
    D3D12_COMPARISON_FUNC StencilFunc;
};
struct D3D12_DEPTH_STENCIL_DESC {
    i32 DepthEnable;
    D3D12_DEPTH_WRITE_MASK DepthWriteMask;
    D3D12_COMPARISON_FUNC DepthFunc;
    i32 StencilEnable;
    u8 StencilReadMask;
    u8 StencilWriteMask;
    D3D12_DEPTH_STENCILOP_DESC FrontFace;
    D3D12_DEPTH_STENCILOP_DESC BackFace;
};
enum D3D12_BLEND {
    D3D12_BLEND_ZERO = 1,
    D3D12_BLEND_ONE = 2,
    D3D12_BLEND_SRC_COLOR = 3,
    D3D12_BLEND_INV_SRC_COLOR = 4,
    D3D12_BLEND_SRC_ALPHA = 5,
    D3D12_BLEND_INV_SRC_ALPHA = 6,
    D3D12_BLEND_DEST_ALPHA = 7,
    D3D12_BLEND_INV_DEST_ALPHA = 8,
    D3D12_BLEND_DEST_COLOR = 9,
    D3D12_BLEND_INV_DEST_COLOR = 10,
    D3D12_BLEND_SRC_ALPHA_SAT = 11,
    D3D12_BLEND_BLEND_FACTOR = 14,
    D3D12_BLEND_INV_BLEND_FACTOR = 15,
    D3D12_BLEND_SRC1_COLOR = 16,
    D3D12_BLEND_INV_SRC1_COLOR = 17,
    D3D12_BLEND_SRC1_ALPHA = 18,
    D3D12_BLEND_INV_SRC1_ALPHA = 19
};
enum D3D12_BLEND_OP {
    D3D12_BLEND_OP_ADD = 1,
    D3D12_BLEND_OP_SUBTRACT = 2,
    D3D12_BLEND_OP_REV_SUBTRACT = 3,
    D3D12_BLEND_OP_MIN = 4,
    D3D12_BLEND_OP_MAX = 5
};
enum D3D12_COLOR_WRITE_ENABLE {
    D3D12_COLOR_WRITE_ENABLE_RED = 1,
    D3D12_COLOR_WRITE_ENABLE_GREEN = 2,
    D3D12_COLOR_WRITE_ENABLE_BLUE = 4,
    D3D12_COLOR_WRITE_ENABLE_ALPHA = 8,
    D3D12_COLOR_WRITE_ENABLE_ALL = D3D12_COLOR_WRITE_ENABLE_RED|D3D12_COLOR_WRITE_ENABLE_GREEN|D3D12_COLOR_WRITE_ENABLE_BLUE|D3D12_COLOR_WRITE_ENABLE_ALPHA
};
enum D3D12_LOGIC_OP {
    D3D12_LOGIC_OP_CLEAR = 0,
    D3D12_LOGIC_OP_SET = (D3D12_LOGIC_OP_CLEAR + 1),
    D3D12_LOGIC_OP_COPY = (D3D12_LOGIC_OP_SET + 1) ,
    D3D12_LOGIC_OP_COPY_INVERTED = (D3D12_LOGIC_OP_COPY + 1),
    D3D12_LOGIC_OP_NOOP = (D3D12_LOGIC_OP_COPY_INVERTED + 1),
    D3D12_LOGIC_OP_INVERT = (D3D12_LOGIC_OP_NOOP + 1),
    D3D12_LOGIC_OP_AND = (D3D12_LOGIC_OP_INVERT + 1),
    D3D12_LOGIC_OP_NAND = (D3D12_LOGIC_OP_AND + 1),
    D3D12_LOGIC_OP_OR = (D3D12_LOGIC_OP_NAND + 1),
    D3D12_LOGIC_OP_NOR = (D3D12_LOGIC_OP_OR + 1),
    D3D12_LOGIC_OP_XOR = (D3D12_LOGIC_OP_NOR + 1),
    D3D12_LOGIC_OP_EQUIV = (D3D12_LOGIC_OP_XOR + 1),
    D3D12_LOGIC_OP_AND_REVERSE = (D3D12_LOGIC_OP_EQUIV + 1),
    D3D12_LOGIC_OP_AND_INVERTED = (D3D12_LOGIC_OP_AND_REVERSE + 1),
    D3D12_LOGIC_OP_OR_REVERSE = (D3D12_LOGIC_OP_AND_INVERTED + 1),
    D3D12_LOGIC_OP_OR_INVERTED = (D3D12_LOGIC_OP_OR_REVERSE + 1)
};
struct D3D12_RENDER_TARGET_BLEND_DESC {
    i32 BlendEnable;
    i32 LogicOpEnable;
    D3D12_BLEND SrcBlend;
    D3D12_BLEND DestBlend;
    D3D12_BLEND_OP BlendOp;
    D3D12_BLEND SrcBlendAlpha;
    D3D12_BLEND DestBlendAlpha;
    D3D12_BLEND_OP BlendOpAlpha;
    D3D12_LOGIC_OP LogicOp;
    u8 RenderTargetWriteMask;
};
struct D3D12_BLEND_DESC {
    i32 AlphaToCoverageEnable;
    i32 IndependentBlendEnable;
    D3D12_RENDER_TARGET_BLEND_DESC RenderTarget[8];
};
enum D3D12_CONSERVATIVE_RASTERIZATION_MODE {
    D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF = 0,
    D3D12_CONSERVATIVE_RASTERIZATION_MODE_ON = 1
};
struct D3D12_RASTERIZER_DESC {
    D3D12_FILL_MODE FillMode;
    D3D12_CULL_MODE CullMode;
    i32 FrontCounterClockwise;
    i32 DepthBias;
    float DepthBiasClamp;
    float SlopeScaledDepthBias;
    i32 DepthClipEnable;
    i32 MultisampleEnable;
    i32 AntialiasedLineEnable;
    u32 ForcedSampleCount;
    D3D12_CONSERVATIVE_RASTERIZATION_MODE ConservativeRaster;
};
enum D3D12_QUERY_HEAP_TYPE {
    D3D12_QUERY_HEAP_TYPE_OCCLUSION = 0,
    D3D12_QUERY_HEAP_TYPE_TIMESTAMP = 1,
    D3D12_QUERY_HEAP_TYPE_PIPELINE_STATISTICS = 2,
    D3D12_QUERY_HEAP_TYPE_SO_STATISTICS = 3
};
struct D3D12_QUERY_HEAP_DESC {
    D3D12_QUERY_HEAP_TYPE Type;
    u32 Count;
    u32 NodeMask;
};
enum D3D12_QUERY_TYPE {
    D3D12_QUERY_TYPE_OCCLUSION = 0,
    D3D12_QUERY_TYPE_BINARY_OCCLUSION = 1,
    D3D12_QUERY_TYPE_TIMESTAMP = 2,
    D3D12_QUERY_TYPE_PIPELINE_STATISTICS = 3,
    D3D12_QUERY_TYPE_SO_STATISTICS_STREAM0 = 4,
    D3D12_QUERY_TYPE_SO_STATISTICS_STREAM1 = 5,
    D3D12_QUERY_TYPE_SO_STATISTICS_STREAM2 = 6,
    D3D12_QUERY_TYPE_SO_STATISTICS_STREAM3 = 7
};
enum D3D12_PREDICATION_OP {
    D3D12_PREDICATION_OP_EQUAL_ZERO = 0,
    D3D12_PREDICATION_OP_NOT_EQUAL_ZERO = 1
};
struct D3D12_QUERY_DATA_PIPELINE_STATISTICS {
    u64 IAVertices;
    u64 IAPrimitives;
    u64 VSInvocations;
    u64 GSInvocations;
    u64 GSPrimitives;
    u64 CInvocations;
    u64 CPrimitives;
    u64 PSInvocations;
    u64 HSInvocations;
    u64 DSInvocations;
    u64 CSInvocations;
};
struct D3D12_QUERY_DATA_SO_STATISTICS {
    u64 NumPrimitivesWritten;
    u64 PrimitivesStorageNeeded;
};
struct D3D12_STREAM_OUTPUT_BUFFER_VIEW {
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
    u64 SizeInBytes;
    D3D12_GPU_VIRTUAL_ADDRESS BufferFilledSizeLocation;
};
struct D3D12_DRAW_ARGUMENTS {
    u32 VertexCountPerInstance;
    u32 InstanceCount;
    u32 StartVertexLocation;
    u32 StartInstanceLocation;
};
struct D3D12_DRAW_INDEXED_ARGUMENTS {
    u32 IndexCountPerInstance;
    u32 InstanceCount;
    u32 StartIndexLocation;
    i32 BaseVertexLocation;
    u32 StartInstanceLocation;
};
struct D3D12_DISPATCH_ARGUMENTS {
    u32 ThreadGroupCountX;
    u32 ThreadGroupCountY;
    u32 ThreadGroupCountZ;
};
struct D3D12_VERTEX_BUFFER_VIEW {
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
    u32 SizeInBytes;
    u32 StrideInBytes;
};
struct D3D12_INDEX_BUFFER_VIEW {
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
    u32 SizeInBytes;
    DXGI_FORMAT Format;
};
enum D3D12_INDIRECT_ARGUMENT_TYPE {
    D3D12_INDIRECT_ARGUMENT_TYPE_DRAW = 0,
    D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED = (D3D12_INDIRECT_ARGUMENT_TYPE_DRAW + 1),
    D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH = (D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED + 1),
    D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW = (D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH + 1),
    D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW = (D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW + 1),
    D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT = (D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW + 1),
    D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW = (D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT + 1),
    D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW = (D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW + 1),
    D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW = (D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW + 1)
};
struct D3D12_INDIRECT_ARGUMENT_DESC {
    D3D12_INDIRECT_ARGUMENT_TYPE Type;
    union {
        struct {
            u32 Slot;
        } VertexBuffer;
        struct {
            u32 RootParameterIndex;
            u32 DestOffsetIn32BitValues;
            u32 Num32BitValuesToSet;
        } Constant;
        struct {
            u32 RootParameterIndex;
        } ConstantBufferView;
        struct {
            u32 RootParameterIndex;
        } ShaderResourceView;
        struct {
            u32 RootParameterIndex;
        } UnorderedAccessView;
    };
};
struct D3D12_COMMAND_SIGNATURE_DESC {
    u32 ByteStride;
    u32 NumArgumentDescs;
    const D3D12_INDIRECT_ARGUMENT_DESC* pArgumentDescs;
    u32 NodeMask;
};
enum D3D12_CLEAR_FLAGS {
    D3D12_CLEAR_FLAG_DEPTH = 0x1,
    D3D12_CLEAR_FLAG_STENCIL = 0x2
};
enum D3D12_COMMAND_QUEUE_FLAGS {
    D3D12_COMMAND_QUEUE_FLAG_NONE = 0,
    D3D12_COMMAND_QUEUE_FLAG_DISABLE_GPU_TIMEOUT = 0x1
};
enum D3D12_COMMAND_QUEUE_PRIORITY {
    D3D12_COMMAND_QUEUE_PRIORITY_NORMAL = 0,
    D3D12_COMMAND_QUEUE_PRIORITY_HIGH = 100
};
struct D3D12_COMMAND_QUEUE_DESC {
    D3D12_COMMAND_LIST_TYPE Type;
    i32 Priority;
    D3D12_COMMAND_QUEUE_FLAGS Flags;
    u32 NodeMask;
};
struct D3D12_SHADER_BYTECODE {
    const void* pShaderBytecode;
    u64 BytecodeLength;
};
struct D3D12_STREAM_OUTPUT_DESC {
    const D3D12_SO_DECLARATION_ENTRY* pSODeclaration;
    u32 NumEntries;
    const u32* pBufferStrides;
    u32 NumStrides;
    u32 RasterizedStream;
};
struct D3D12_INPUT_LAYOUT_DESC {
    const D3D12_INPUT_ELEMENT_DESC* pInputElementDescs;
    u32 NumElements;
};
enum D3D12_INDEX_BUFFER_STRIP_CUT_VALUE {
    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_DISABLED = 0,
    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFF = 1,
    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFFFFFF = 2
};
struct D3D12_CACHED_PIPELINE_STATE {
    const void* pCachedBlob;
    u64 CachedBlobSizeInBytes;
};
enum D3D12_PIPELINE_STATE_FLAGS {
    D3D12_PIPELINE_STATE_FLAG_NONE = 0,
    D3D12_PIPELINE_STATE_FLAG_TOOL_DEBUG = 0x1
};
struct D3D12_GRAPHICS_PIPELINE_STATE_DESC {
    ID3D12RootSignature* pRootSignature;
    D3D12_SHADER_BYTECODE VS;
    D3D12_SHADER_BYTECODE PS;
    D3D12_SHADER_BYTECODE DS;
    D3D12_SHADER_BYTECODE HS;
    D3D12_SHADER_BYTECODE GS;
    D3D12_STREAM_OUTPUT_DESC StreamOutput;
    D3D12_BLEND_DESC BlendState;
    u32 SampleMask;
    D3D12_RASTERIZER_DESC RasterizerState;
    D3D12_DEPTH_STENCIL_DESC DepthStencilState;
    D3D12_INPUT_LAYOUT_DESC InputLayout;
    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue;
    D3D12_PRIMITIVE_TOPOLOGY_TYPE PrimitiveTopologyType;
    u32 NumRenderTargets;
    DXGI_FORMAT RTVFormats[8];
    DXGI_FORMAT DSVFormat;
    DXGI_SAMPLE_DESC SampleDesc;
    u32 NodeMask;
    D3D12_CACHED_PIPELINE_STATE CachedPSO;
    D3D12_PIPELINE_STATE_FLAGS Flags;
};
struct D3D12_COMPUTE_PIPELINE_STATE_DESC {
    ID3D12RootSignature* pRootSignature;
    D3D12_SHADER_BYTECODE CS;
    u32 NodeMask;
    D3D12_CACHED_PIPELINE_STATE CachedPSO;
    D3D12_PIPELINE_STATE_FLAGS Flags;
};
enum D3D12_FEATURE {
    D3D12_FEATURE_D3D12_OPTIONS = 0,
    D3D12_FEATURE_ARCHITECTURE = 1,
    D3D12_FEATURE_FEATURE_LEVELS = 2,
    D3D12_FEATURE_FORMAT_SUPPORT = 3,
    D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS = 4,
    D3D12_FEATURE_FORMAT_INFO = 5,
    D3D12_FEATURE_GPU_VIRTUAL_ADDRESS_SUPPORT = 6,
    D3D12_FEATURE_SHADER_MODEL = 7,
    D3D12_FEATURE_D3D12_OPTIONS1 = 8,
    D3D12_FEATURE_ROOT_SIGNATURE = 12
};
enum D3D12_SHADER_MIN_PRECISION_SUPPORT {
    D3D12_SHADER_MIN_PRECISION_SUPPORT_NONE = 0,
    D3D12_SHADER_MIN_PRECISION_SUPPORT_10_BIT = 0x1,
    D3D12_SHADER_MIN_PRECISION_SUPPORT_16_BIT = 0x2
};
enum D3D12_TILED_RESOURCES_TIER {
    D3D12_TILED_RESOURCES_TIER_NOT_SUPPORTED = 0,
    D3D12_TILED_RESOURCES_TIER_1 = 1,
    D3D12_TILED_RESOURCES_TIER_2 = 2,
    D3D12_TILED_RESOURCES_TIER_3 = 3
};
enum D3D12_RESOURCE_BINDING_TIER {
    D3D12_RESOURCE_BINDING_TIER_1 = 1,
    D3D12_RESOURCE_BINDING_TIER_2 = 2,
    D3D12_RESOURCE_BINDING_TIER_3 = 3
};
enum D3D12_CONSERVATIVE_RASTERIZATION_TIER {
    D3D12_CONSERVATIVE_RASTERIZATION_TIER_NOT_SUPPORTED = 0,
    D3D12_CONSERVATIVE_RASTERIZATION_TIER_1 = 1,
    D3D12_CONSERVATIVE_RASTERIZATION_TIER_2 = 2,
    D3D12_CONSERVATIVE_RASTERIZATION_TIER_3 = 3
};
enum D3D12_FORMAT_SUPPORT1 {
    D3D12_FORMAT_SUPPORT1_NONE = 0,
    D3D12_FORMAT_SUPPORT1_BUFFER = 0x1,
    D3D12_FORMAT_SUPPORT1_IA_VERTEX_BUFFER = 0x2,
    D3D12_FORMAT_SUPPORT1_IA_INDEX_BUFFER = 0x4,
    D3D12_FORMAT_SUPPORT1_SO_BUFFER = 0x8,
    D3D12_FORMAT_SUPPORT1_TEXTURE1D = 0x10,
    D3D12_FORMAT_SUPPORT1_TEXTURE2D = 0x20,
    D3D12_FORMAT_SUPPORT1_TEXTURE3D = 0x40,
    D3D12_FORMAT_SUPPORT1_TEXTURECUBE = 0x80,
    D3D12_FORMAT_SUPPORT1_SHADER_LOAD = 0x100,
    D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE = 0x200,
    D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE_COMPARISON = 0x400,
    D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE_MONO_TEXT = 0x800,
    D3D12_FORMAT_SUPPORT1_MIP = 0x1000,
    D3D12_FORMAT_SUPPORT1_RENDER_TARGET = 0x4000,
    D3D12_FORMAT_SUPPORT1_BLENDABLE = 0x8000,
    D3D12_FORMAT_SUPPORT1_DEPTH_STENCIL = 0x10000,
    D3D12_FORMAT_SUPPORT1_MULTISAMPLE_RESOLVE = 0x40000,
    D3D12_FORMAT_SUPPORT1_DISPLAY = 0x80000,
    D3D12_FORMAT_SUPPORT1_CAST_WITHIN_BIT_LAYOUT = 0x100000,
    D3D12_FORMAT_SUPPORT1_MULTISAMPLE_RENDERTARGET = 0x200000,
    D3D12_FORMAT_SUPPORT1_MULTISAMPLE_LOAD = 0x400000,
    D3D12_FORMAT_SUPPORT1_SHADER_GATHER = 0x800000,
    D3D12_FORMAT_SUPPORT1_BACK_BUFFER_CAST = 0x1000000,
    D3D12_FORMAT_SUPPORT1_TYPED_UNORDERED_ACCESS_VIEW = 0x2000000,
    D3D12_FORMAT_SUPPORT1_SHADER_GATHER_COMPARISON = 0x4000000,
    D3D12_FORMAT_SUPPORT1_DECODER_OUTPUT = 0x8000000,
    D3D12_FORMAT_SUPPORT1_VIDEO_PROCESSOR_OUTPUT = 0x10000000,
    D3D12_FORMAT_SUPPORT1_VIDEO_PROCESSOR_INPUT = 0x20000000,
    D3D12_FORMAT_SUPPORT1_VIDEO_ENCODER = 0x40000000
};
enum D3D12_FORMAT_SUPPORT2 {
    D3D12_FORMAT_SUPPORT2_NONE = 0,
    D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_ADD = 0x1,
    D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_BITWISE_OPS = 0x2,
    D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_COMPARE_STORE_OR_COMPARE_EXCHANGE = 0x4,
    D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_EXCHANGE = 0x8,
    D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_SIGNED_MIN_OR_MAX = 0x10,
    D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_UNSIGNED_MIN_OR_MAX = 0x20,
    D3D12_FORMAT_SUPPORT2_UAV_TYPED_LOAD = 0x40,
    D3D12_FORMAT_SUPPORT2_UAV_TYPED_STORE = 0x80,
    D3D12_FORMAT_SUPPORT2_OUTPUT_MERGER_LOGIC_OP = 0x100,
    D3D12_FORMAT_SUPPORT2_TILED = 0x200,
    D3D12_FORMAT_SUPPORT2_MULTIPLANE_OVERLAY = 0x4000
};
enum D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE = 0,
    D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_TILED_RESOURCE = 0x1
};
enum D3D12_CROSS_NODE_SHARING_TIER {
    D3D12_CROSS_NODE_SHARING_TIER_NOT_SUPPORTED = 0,
    D3D12_CROSS_NODE_SHARING_TIER_1_EMULATED = 1,
    D3D12_CROSS_NODE_SHARING_TIER_1 = 2,
    D3D12_CROSS_NODE_SHARING_TIER_2 = 3
};
enum D3D12_RESOURCE_HEAP_TIER {
    D3D12_RESOURCE_HEAP_TIER_1 = 1,
    D3D12_RESOURCE_HEAP_TIER_2 = 2
};
struct D3D12_FEATURE_DATA_D3D12_OPTIONS {
    i32 DoublePrecisionFloatShaderOps;
    i32 OutputMergerLogicOp;
    D3D12_SHADER_MIN_PRECISION_SUPPORT MinPrecisionSupport;
    D3D12_TILED_RESOURCES_TIER TiledResourcesTier;
    D3D12_RESOURCE_BINDING_TIER ResourceBindingTier;
    i32 PSSpecifiedStencilRefSupported;
    i32 TypedUAVLoadAdditionalFormats;
    i32 ROVsSupported;
    D3D12_CONSERVATIVE_RASTERIZATION_TIER ConservativeRasterizationTier;
    u32 MaxGPUVirtualAddressBitsPerResource;
    i32 StandardSwizzle64KBSupported;
    D3D12_CROSS_NODE_SHARING_TIER CrossNodeSharingTier;
    i32 CrossAdapterRowMajorTextureSupported;
    i32 VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation;
    D3D12_RESOURCE_HEAP_TIER ResourceHeapTier;
};
struct D3D12_FEATURE_DATA_D3D12_OPTIONS1 {
    i32 WaveOps;
    u32 WaveLaneCountMin;
    u32 WaveLaneCountMax;
    u32 TotalLaneCount;
    i32 ExpandedComputeResourceStates;
    i32 Int64ShaderOps;
};
enum D3D_ROOT_SIGNATURE_VERSION {
    D3D_ROOT_SIGNATURE_VERSION_1 = 0x1,
    D3D_ROOT_SIGNATURE_VERSION_1_0 = 0x1,
    D3D_ROOT_SIGNATURE_VERSION_1_1 = 0x2
};
struct D3D12_FEATURE_DATA_ROOT_SIGNATURE {
    D3D_ROOT_SIGNATURE_VERSION HighestVersion;
};
struct D3D12_FEATURE_DATA_ARCHITECTURE {
    u32 NodeIndex;
    i32 TileBasedRenderer;
    i32 UMA;
    i32 CacheCoherentUMA;
};
enum D3D_FEATURE_LEVEL {
    D3D_FEATURE_LEVEL_9_1 = 0x9100,
    D3D_FEATURE_LEVEL_9_2 = 0x9200,
    D3D_FEATURE_LEVEL_9_3 = 0x9300,
    D3D_FEATURE_LEVEL_10_0 = 0xa000,
    D3D_FEATURE_LEVEL_10_1 = 0xa100,
    D3D_FEATURE_LEVEL_11_0 = 0xb000,
    D3D_FEATURE_LEVEL_11_1 = 0xb100,
    D3D_FEATURE_LEVEL_12_0 = 0xc000,
    D3D_FEATURE_LEVEL_12_1 = 0xc100
};
struct D3D12_FEATURE_DATA_FEATURE_LEVELS {
    u32 NumFeatureLevels;
    const D3D_FEATURE_LEVEL* pFeatureLevelsRequested;
    D3D_FEATURE_LEVEL MaxSupportedFeatureLevel;
};
enum D3D_SHADER_MODEL {
    D3D_SHADER_MODEL_5_1 = 0x51,
    D3D_SHADER_MODEL_6_0 = 0x60
};
struct D3D12_FEATURE_DATA_SHADER_MODEL {
    D3D_SHADER_MODEL HighestShaderModel;
};
struct D3D12_FEATURE_DATA_FORMAT_SUPPORT {
    DXGI_FORMAT Format;
    D3D12_FORMAT_SUPPORT1 Support1;
    D3D12_FORMAT_SUPPORT2 Support2;
};
struct D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS {
    DXGI_FORMAT Format;
    u32 SampleCount;
    D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS Flags;
    u32 NumQualityLevels;
};
struct D3D12_FEATURE_DATA_FORMAT_INFO {
    DXGI_FORMAT Format;
    u8 PlaneCount;
};
struct D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {
    u32 MaxGPUVirtualAddressBitsPerResource;
    u32 MaxGPUVirtualAddressBitsPerProcess;
};
struct D3D12_RESOURCE_ALLOCATION_INFO {
    u64 SizeInBytes;
    u64 Alignment;
};
enum D3D12_SHADER_COMPONENT_MAPPING {
    D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_0 = 0,
    D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_1 = 1,
    D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_2 = 2,
    D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_3 = 3,
    D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0 = 4,
    D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1 = 5
};
enum D3D12_BUFFER_SRV_FLAGS {
    D3D12_BUFFER_SRV_FLAG_NONE = 0,
    D3D12_BUFFER_SRV_FLAG_RAW = 0x1
};
struct D3D12_BUFFER_SRV {
    u64 FirstElement;
    u32 NumElements;
    u32 StructureByteStride;
    D3D12_BUFFER_SRV_FLAGS Flags;
};
struct D3D12_TEX1D_SRV {
    u32 MostDetailedMip;
    u32 MipLevels;
    float ResourceMinLODClamp;
};
struct D3D12_TEX1D_ARRAY_SRV {
    u32 MostDetailedMip;
    u32 MipLevels;
    u32 FirstArraySlice;
    u32 ArraySize;
    float ResourceMinLODClamp;
};
struct D3D12_TEX2D_SRV {
    u32 MostDetailedMip;
    u32 MipLevels;
    u32 PlaneSlice;
    float ResourceMinLODClamp;
};
struct D3D12_TEX2D_ARRAY_SRV {
    u32 MostDetailedMip;
    u32 MipLevels;
    u32 FirstArraySlice;
    u32 ArraySize;
    u32 PlaneSlice;
    float ResourceMinLODClamp;
};
struct D3D12_TEX3D_SRV {
    u32 MostDetailedMip;
    u32 MipLevels;
    float ResourceMinLODClamp;
};
struct D3D12_TEXCUBE_SRV {
    u32 MostDetailedMip;
    u32 MipLevels;
    float ResourceMinLODClamp;
};
struct D3D12_TEXCUBE_ARRAY_SRV {
    u32 MostDetailedMip;
    u32 MipLevels;
    u32 First2DArrayFace;
    u32 NumCubes;
    float ResourceMinLODClamp;
};
struct D3D12_TEX2Dwin_SRV {
    u32 UnusedField_NothingToDefine;
};
struct D3D12_TEX2Dwin_ARRAY_SRV {
    u32 FirstArraySlice;
    u32 ArraySize;
};
enum D3D12_SRV_DIMENSION {
    D3D12_SRV_DIMENSION_UNKNOWN = 0,
    D3D12_SRV_DIMENSION_BUFFER = 1,
    D3D12_SRV_DIMENSION_TEXTURE1D = 2,
    D3D12_SRV_DIMENSION_TEXTURE1DARRAY = 3,
    D3D12_SRV_DIMENSION_TEXTURE2D = 4,
    D3D12_SRV_DIMENSION_TEXTURE2DARRAY = 5,
    D3D12_SRV_DIMENSION_TEXTURE2DMS = 6,
    D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY = 7,
    D3D12_SRV_DIMENSION_TEXTURE3D = 8,
    D3D12_SRV_DIMENSION_TEXTURECUBE = 9,
    D3D12_SRV_DIMENSION_TEXTURECUBEARRAY = 10
};
struct D3D12_SHADER_RESOURCE_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D12_SRV_DIMENSION ViewDimension;
    u32 Shader4ComponentMapping;
    union {
        D3D12_BUFFER_SRV Buffer;
        D3D12_TEX1D_SRV Texture1D;
        D3D12_TEX1D_ARRAY_SRV Texture1DArray;
        D3D12_TEX2D_SRV Texture2D;
        D3D12_TEX2D_ARRAY_SRV Texture2DArray;
        D3D12_TEX2Dwin_SRV Texture2DMS;
        D3D12_TEX2Dwin_ARRAY_SRV Texture2DMSArray;
        D3D12_TEX3D_SRV Texture3D;
        D3D12_TEXCUBE_SRV TextureCube;
        D3D12_TEXCUBE_ARRAY_SRV TextureCubeArray;
    };
};
enum D3D12_FILTER {
    D3D12_FILTER_MIN_MAG_MIP_POINT = 0,
    D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR = 0x1,
    D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x4,
    D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR = 0x5,
    D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT = 0x10,
    D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11,
    D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT = 0x14,
    D3D12_FILTER_MIN_MAG_MIP_LINEAR = 0x15,
    D3D12_FILTER_ANISOTROPIC = 0x55,
    D3D12_FILTER_COMPARISON_MIN_MAG_MIP_POINT = 0x80,
    D3D12_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR = 0x81,
    D3D12_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x84,
    D3D12_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR = 0x85,
    D3D12_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT = 0x90,
    D3D12_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x91,
    D3D12_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT = 0x94,
    D3D12_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR = 0x95,
    D3D12_FILTER_COMPARISON_ANISOTROPIC = 0xd5,
    D3D12_FILTER_MINIMUM_MIN_MAG_MIP_POINT = 0x100,
    D3D12_FILTER_MINIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x101,
    D3D12_FILTER_MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x104,
    D3D12_FILTER_MINIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x105,
    D3D12_FILTER_MINIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x110,
    D3D12_FILTER_MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x111,
    D3D12_FILTER_MINIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x114,
    D3D12_FILTER_MINIMUM_MIN_MAG_MIP_LINEAR = 0x115,
    D3D12_FILTER_MINIMUM_ANISOTROPIC = 0x155,
    D3D12_FILTER_MAXIMUM_MIN_MAG_MIP_POINT = 0x180,
    D3D12_FILTER_MAXIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x181,
    D3D12_FILTER_MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x184,
    D3D12_FILTER_MAXIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x185,
    D3D12_FILTER_MAXIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x190,
    D3D12_FILTER_MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x191,
    D3D12_FILTER_MAXIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x194,
    D3D12_FILTER_MAXIMUM_MIN_MAG_MIP_LINEAR = 0x195,
    D3D12_FILTER_MAXIMUM_ANISOTROPIC = 0x1d5
};
enum D3D12_FILTER_TYPE {
    D3D12_FILTER_TYPE_POINT = 0,
    D3D12_FILTER_TYPE_LINEAR = 1
};
enum D3D12_FILTER_REDUCTION_TYPE {
    D3D12_FILTER_REDUCTION_TYPE_STANDARD = 0,
    D3D12_FILTER_REDUCTION_TYPE_COMPARISON = 1,
    D3D12_FILTER_REDUCTION_TYPE_MINIMUM = 2,
    D3D12_FILTER_REDUCTION_TYPE_MAXIMUM = 3
};
enum D3D12_TEXTURE_ADDRESS_MODE {
    D3D12_TEXTURE_ADDRESS_MODE_WRAP = 1,
    D3D12_TEXTURE_ADDRESS_MODE_MIRROR = 2,
    D3D12_TEXTURE_ADDRESS_MODE_CLAMP = 3,
    D3D12_TEXTURE_ADDRESS_MODE_BORDER = 4,
    D3D12_TEXTURE_ADDRESS_MODE_MIRROR_ONCE = 5
};
struct D3D12_SAMPLER_DESC {
    D3D12_FILTER Filter;
    D3D12_TEXTURE_ADDRESS_MODE AddressU;
    D3D12_TEXTURE_ADDRESS_MODE AddressV;
    D3D12_TEXTURE_ADDRESS_MODE AddressW;
    float MipLODBias;
    u32 MaxAnisotropy;
    D3D12_COMPARISON_FUNC ComparisonFunc;
    float BorderColor[4];
    float MinLOD;
    float MaxLOD;
};
struct D3D12_CONSTANT_BUFFER_VIEW_DESC {
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
    u32 SizeInBytes;
};
enum D3D12_BUFFER_UAV_FLAGS {
    D3D12_BUFFER_UAV_FLAG_NONE = 0,
    D3D12_BUFFER_UAV_FLAG_RAW = 0x1
};
struct D3D12_BUFFER_UAV {
    u64 FirstElement;
    u32 NumElements;
    u32 StructureByteStride;
    u64 CounterOffsetInBytes;
    D3D12_BUFFER_UAV_FLAGS Flags;
};
struct D3D12_TEX1D_UAV {
    u32 MipSlice;
};
struct D3D12_TEX1D_ARRAY_UAV {
    u32 MipSlice;
    u32 FirstArraySlice;
    u32 ArraySize;
};
struct D3D12_TEX2D_UAV {
    u32 MipSlice;
    u32 PlaneSlice;
};
struct D3D12_TEX2D_ARRAY_UAV {
    u32 MipSlice;
    u32 FirstArraySlice;
    u32 ArraySize;
    u32 PlaneSlice;
};
struct D3D12_TEX3D_UAV {
    u32 MipSlice;
    u32 FirstWSlice;
    u32 WSize;
};
enum D3D12_UAV_DIMENSION {
    D3D12_UAV_DIMENSION_UNKNOWN = 0,
    D3D12_UAV_DIMENSION_BUFFER = 1,
    D3D12_UAV_DIMENSION_TEXTURE1D = 2,
    D3D12_UAV_DIMENSION_TEXTURE1DARRAY = 3,
    D3D12_UAV_DIMENSION_TEXTURE2D = 4,
    D3D12_UAV_DIMENSION_TEXTURE2DARRAY = 5,
    D3D12_UAV_DIMENSION_TEXTURE3D = 8
};
struct D3D12_UNORDERED_ACCESS_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D12_UAV_DIMENSION ViewDimension;
    union {
        D3D12_BUFFER_UAV Buffer;
        D3D12_TEX1D_UAV Texture1D;
        D3D12_TEX1D_ARRAY_UAV Texture1DArray;
        D3D12_TEX2D_UAV Texture2D;
        D3D12_TEX2D_ARRAY_UAV Texture2DArray;
        D3D12_TEX3D_UAV Texture3D;
    };
};
struct D3D12_BUFFER_RTV {
    u64 FirstElement;
    u32 NumElements;
};
struct D3D12_TEX1D_RTV {
    u32 MipSlice;
};
struct D3D12_TEX1D_ARRAY_RTV {
    u32 MipSlice;
    u32 FirstArraySlice;
    u32 ArraySize;
};
struct D3D12_TEX2D_RTV {
    u32 MipSlice;
    u32 PlaneSlice;
};
struct D3D12_TEX2Dwin_RTV {
    u32 UnusedField_NothingToDefine;
};
struct D3D12_TEX2D_ARRAY_RTV {
    u32 MipSlice;
    u32 FirstArraySlice;
    u32 ArraySize;
    u32 PlaneSlice;
};
struct D3D12_TEX2Dwin_ARRAY_RTV {
    u32 FirstArraySlice;
    u32 ArraySize;
};
struct D3D12_TEX3D_RTV {
    u32 MipSlice;
    u32 FirstWSlice;
    u32 WSize;
};
enum D3D12_RTV_DIMENSION {
    D3D12_RTV_DIMENSION_UNKNOWN = 0,
    D3D12_RTV_DIMENSION_BUFFER = 1,
    D3D12_RTV_DIMENSION_TEXTURE1D = 2,
    D3D12_RTV_DIMENSION_TEXTURE1DARRAY = 3,
    D3D12_RTV_DIMENSION_TEXTURE2D = 4,
    D3D12_RTV_DIMENSION_TEXTURE2DARRAY = 5,
    D3D12_RTV_DIMENSION_TEXTURE2DMS = 6,
    D3D12_RTV_DIMENSION_TEXTURE2DMSARRAY = 7,
    D3D12_RTV_DIMENSION_TEXTURE3D = 8
};
struct D3D12_RENDER_TARGET_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D12_RTV_DIMENSION ViewDimension;
    union {
        D3D12_BUFFER_RTV Buffer;
        D3D12_TEX1D_RTV Texture1D;
        D3D12_TEX1D_ARRAY_RTV Texture1DArray;
        D3D12_TEX2D_RTV Texture2D;
        D3D12_TEX2D_ARRAY_RTV Texture2DArray;
        D3D12_TEX2Dwin_RTV Texture2DMS;
        D3D12_TEX2Dwin_ARRAY_RTV Texture2DMSArray;
        D3D12_TEX3D_RTV Texture3D;
    };
};
struct D3D12_TEX1D_DSV {
    u32 MipSlice;
};
struct D3D12_TEX1D_ARRAY_DSV {
    u32 MipSlice;
    u32 FirstArraySlice;
    u32 ArraySize;
};
struct D3D12_TEX2D_DSV {
    u32 MipSlice;
};
struct D3D12_TEX2D_ARRAY_DSV {
    u32 MipSlice;
    u32 FirstArraySlice;
    u32 ArraySize;
};
struct D3D12_TEX2Dwin_DSV {
    u32 UnusedField_NothingToDefine;
};
struct D3D12_TEX2Dwin_ARRAY_DSV {
    u32 FirstArraySlice;
    u32 ArraySize;
};
enum D3D12_DSV_FLAGS {
    D3D12_DSV_FLAG_NONE = 0,
    D3D12_DSV_FLAG_READ_ONLY_DEPTH = 0x1,
    D3D12_DSV_FLAG_READ_ONLY_STENCIL = 0x2
};
enum D3D12_DSV_DIMENSION {
    D3D12_DSV_DIMENSION_UNKNOWN = 0,
    D3D12_DSV_DIMENSION_TEXTURE1D = 1,
    D3D12_DSV_DIMENSION_TEXTURE1DARRAY = 2,
    D3D12_DSV_DIMENSION_TEXTURE2D = 3,
    D3D12_DSV_DIMENSION_TEXTURE2DARRAY = 4,
    D3D12_DSV_DIMENSION_TEXTURE2DMS = 5,
    D3D12_DSV_DIMENSION_TEXTURE2DMSARRAY = 6
};
struct D3D12_DEPTH_STENCIL_VIEW_DESC {
    DXGI_FORMAT Format;
    D3D12_DSV_DIMENSION ViewDimension;
    D3D12_DSV_FLAGS Flags;
    union {
        D3D12_TEX1D_DSV Texture1D;
        D3D12_TEX1D_ARRAY_DSV Texture1DArray;
        D3D12_TEX2D_DSV Texture2D;
        D3D12_TEX2D_ARRAY_DSV Texture2DArray;
        D3D12_TEX2Dwin_DSV Texture2DMS;
        D3D12_TEX2Dwin_ARRAY_DSV Texture2DMSArray;
    };
};
struct D3D12_DEPTH_STENCIL_VALUE {
    float Depth;
    u8 Stencil;
};
struct D3D12_CLEAR_VALUE {
    DXGI_FORMAT Format;
    union {
        float Color[4];
        D3D12_DEPTH_STENCIL_VALUE DepthStencil;
    };
};
enum D3D12_FENCE_FLAGS {
    D3D12_FENCE_FLAG_NONE = 0,
    D3D12_FENCE_FLAG_SHARED = 0x1,
    D3D12_FENCE_FLAG_SHARED_CROSS_ADAPTER = 0x2
};
struct D3D12_PACKED_MIP_INFO {
    u8 NumStandardMips;
    u8 NumPackedMips;
    u32 NumTilesForPackedMips;
    u32 StartTileIndexInOverallResource;
};
struct D3D12_SUBRESOURCE_DATA {
    const void* pData;
    i64 RowPitch;
    i64 SlicePitch;
};
struct D3D12_MEMCPY_DEST {
    void* pData;
    u64 RowPitch;
    u64 SlicePitch;
};
struct IUnknown {
    virtual i32 STDCALL QueryInterface(const win_GUID&, void**) = 0;
    virtual u32 STDCALL AddRef() = 0;
    virtual u32 STDCALL Release() = 0;
};
struct ID3DBlob : public IUnknown {
    virtual void* STDCALL GetBufferPointer() = 0;
    virtual u64 STDCALL GetBufferSize() = 0;
};
struct ID3D12Object : public IUnknown {
    virtual i32 STDCALL GetPrivateData(const win_GUID&, u32*, void*) = 0;
    virtual i32 STDCALL SetPrivateData(const win_GUID&, u32, const void*) = 0;
    virtual i32 STDCALL SetPrivateDataInterface(const win_GUID&, const IUnknown*) = 0;
    virtual i32 STDCALL SetName(const u16*) = 0;
};
struct ID3D12DeviceChild : public ID3D12Object {
    virtual i32 STDCALL GetDevice(const win_GUID&, void**) = 0;
};
struct ID3D12RootSignature : public ID3D12DeviceChild {
};
struct ID3D12Pageable : public ID3D12DeviceChild {
};
struct ID3D12Heap : public ID3D12Pageable {
    virtual D3D12_HEAP_DESC STDCALL GetDesc() = 0;
};
struct ID3D12Resource : public ID3D12Pageable {
    virtual i32 STDCALL Map(u32, const D3D12_RANGE*, void**) = 0;
    virtual void STDCALL Unmap(u32, const D3D12_RANGE*) = 0;
    virtual D3D12_RESOURCE_DESC STDCALL GetDesc() = 0;
    virtual D3D12_GPU_VIRTUAL_ADDRESS STDCALL GetGPUVirtualAddress() = 0;
    virtual i32 STDCALL WriteToSubresource(u32, const D3D12_BOX*, const void*, u32, u32) = 0;
    virtual i32 STDCALL ReadFromSubresource(void*, u32, u32, u32, const D3D12_BOX*) = 0;
    virtual i32 STDCALL GetHeapProperties(D3D12_HEAP_PROPERTIES*, D3D12_HEAP_FLAGS*) = 0;
};
struct ID3D12CommandAllocator : public ID3D12Pageable {
    virtual i32 STDCALL Reset() = 0;
};
struct ID3D12Fence : public ID3D12Pageable {
    virtual u64 STDCALL GetCompletedValue() = 0;
    virtual i32 STDCALL SetEventOnCompletion(u64, void*) = 0;
    virtual i32 STDCALL Signal(u64) = 0;
};
struct ID3D12PipelineState : public ID3D12Pageable {
    virtual i32 STDCALL GetCachedBlob(ID3DBlob**) = 0;
};
struct ID3D12DescriptorHeap : public ID3D12Pageable {
    virtual D3D12_DESCRIPTOR_HEAP_DESC STDCALL GetDesc() = 0;
    virtual D3D12_CPU_DESCRIPTOR_HANDLE STDCALL GetCPUDescriptorHandleForHeapStart() = 0;
    virtual D3D12_GPU_DESCRIPTOR_HANDLE STDCALL GetGPUDescriptorHandleForHeapStart() = 0;
};
struct ID3D12QueryHeap : public ID3D12Pageable {
};
struct ID3D12CommandSignature : public ID3D12Pageable {
};
struct ID3D12CommandList : public ID3D12DeviceChild {
    virtual D3D12_COMMAND_LIST_TYPE STDCALL GetType() = 0;
};
struct ID3D12GraphicsCommandList : public ID3D12CommandList {
    virtual i32 STDCALL Close() = 0;
    virtual i32 STDCALL Reset(ID3D12CommandAllocator*, ID3D12PipelineState*) = 0;
    virtual void STDCALL ClearState(ID3D12PipelineState*) = 0;
    virtual void STDCALL DrawInstanced(u32, u32, u32, u32) = 0;
    virtual void STDCALL DrawIndexedInstanced(u32, u32, u32, i32, u32) = 0;
    virtual void STDCALL Dispatch(u32, u32, u32) = 0;
    virtual void STDCALL CopyBufferRegion(ID3D12Resource*, u64, ID3D12Resource*, u64, u64) = 0;
    virtual void STDCALL CopyTextureRegion(const D3D12_TEXTURE_COPY_LOCATION*, u32, u32, u32, const D3D12_TEXTURE_COPY_LOCATION*, const D3D12_BOX*) = 0;
    virtual void STDCALL CopyResource(ID3D12Resource*, ID3D12Resource*) = 0;
    virtual void STDCALL CopyTiles(ID3D12Resource*, const D3D12_TILED_RESOURCE_COORDINATE*, const D3D12_TILE_REGION_SIZE*, ID3D12Resource*, u64, D3D12_TILE_COPY_FLAGS) = 0;
    virtual void STDCALL ResolveSubresource(ID3D12Resource*, u32, ID3D12Resource*, u32, DXGI_FORMAT) = 0;
    virtual void STDCALL IASetPrimitiveTopology(D3D12_PRIMITIVE_TOPOLOGY) = 0;
    virtual void STDCALL RSSetViewports(u32, const D3D12_VIEWPORT*) = 0;
    virtual void STDCALL RSSetScissorRects(u32, const D3D12_RECT*) = 0;
    virtual void STDCALL OMSetBlendFactor(const float[4]) = 0;
    virtual void STDCALL OMSetStencilRef(u32) = 0;
    virtual void STDCALL SetPipelineState(ID3D12PipelineState*) = 0;
    virtual void STDCALL ResourceBarrier(u32, const D3D12_RESOURCE_BARRIER*) = 0;
    virtual void STDCALL ExecuteBundle(ID3D12GraphicsCommandList*) = 0;
    virtual void STDCALL SetDescriptorHeaps(u32, ID3D12DescriptorHeap* const*) = 0;
    virtual void STDCALL SetComputeRootSignature(ID3D12RootSignature*) = 0;
    virtual void STDCALL SetGraphicsRootSignature(ID3D12RootSignature*) = 0;
    virtual void STDCALL SetComputeRootDescriptorTable(u32, D3D12_GPU_DESCRIPTOR_HANDLE) = 0;
    virtual void STDCALL SetGraphicsRootDescriptorTable(u32, D3D12_GPU_DESCRIPTOR_HANDLE) = 0;
    virtual void STDCALL SetComputeRoot32BitConstant(u32, u32, u32) = 0;
    virtual void STDCALL SetGraphicsRoot32BitConstant(u32, u32, u32) = 0;
    virtual void STDCALL SetComputeRoot32BitConstants(u32, u32, const void*, u32) = 0;
    virtual void STDCALL SetGraphicsRoot32BitConstants(u32, u32, const void*, u32) = 0;
    virtual void STDCALL SetComputeRootConstantBufferView(u32, D3D12_GPU_VIRTUAL_ADDRESS) = 0;
    virtual void STDCALL SetGraphicsRootConstantBufferView(u32, D3D12_GPU_VIRTUAL_ADDRESS) = 0;
    virtual void STDCALL SetComputeRootShaderResourceView(u32, D3D12_GPU_VIRTUAL_ADDRESS) = 0;
    virtual void STDCALL SetGraphicsRootShaderResourceView(u32, D3D12_GPU_VIRTUAL_ADDRESS) = 0;
    virtual void STDCALL SetComputeRootUnorderedAccessView(u32, D3D12_GPU_VIRTUAL_ADDRESS) = 0;
    virtual void STDCALL SetGraphicsRootUnorderedAccessView(u32, D3D12_GPU_VIRTUAL_ADDRESS) = 0;
    virtual void STDCALL IASetIndexBuffer(const D3D12_INDEX_BUFFER_VIEW*) = 0;
    virtual void STDCALL IASetVertexBuffers(u32, u32, const D3D12_VERTEX_BUFFER_VIEW*) = 0;
    virtual void STDCALL SOSetTargets(u32, u32, const D3D12_STREAM_OUTPUT_BUFFER_VIEW*) = 0;
    virtual void STDCALL OMSetRenderTargets(u32, const D3D12_CPU_DESCRIPTOR_HANDLE*, i32, const D3D12_CPU_DESCRIPTOR_HANDLE*) = 0;
    virtual void STDCALL ClearDepthStencilView(D3D12_CPU_DESCRIPTOR_HANDLE, D3D12_CLEAR_FLAGS, float, u8, u32, const D3D12_RECT*) = 0;
    virtual void STDCALL ClearRenderTargetView(D3D12_CPU_DESCRIPTOR_HANDLE, const float[4], u32, const D3D12_RECT*) = 0;
    virtual void STDCALL ClearUnorderedAccessViewUint(D3D12_GPU_DESCRIPTOR_HANDLE, D3D12_CPU_DESCRIPTOR_HANDLE, ID3D12Resource*, const u32[4], u32, const D3D12_RECT*) = 0;
    virtual void STDCALL ClearUnorderedAccessViewFloat(D3D12_GPU_DESCRIPTOR_HANDLE, D3D12_CPU_DESCRIPTOR_HANDLE, ID3D12Resource*, const float[4], u32, const D3D12_RECT*) = 0;
    virtual void STDCALL DiscardResource(ID3D12Resource*, const D3D12_DISCARD_REGION*) = 0;
    virtual void STDCALL BeginQuery(ID3D12QueryHeap*, D3D12_QUERY_TYPE, u32) = 0;
    virtual void STDCALL EndQuery(ID3D12QueryHeap*, D3D12_QUERY_TYPE, u32) = 0;
    virtual void STDCALL ResolveQueryData(ID3D12QueryHeap*, D3D12_QUERY_TYPE, u32, u32, ID3D12Resource*, u64) = 0;
    virtual void STDCALL SetPredication(ID3D12Resource*, u64, D3D12_PREDICATION_OP) = 0;
    virtual void STDCALL SetMarker(u32, const void*, u32) = 0;
    virtual void STDCALL BeginEvent(u32, const void*, u32) = 0;
    virtual void STDCALL EndEvent() = 0;
    virtual void STDCALL ExecuteIndirect(ID3D12CommandSignature*, u32, ID3D12Resource*, u64, ID3D12Resource*, u64) = 0;
};
struct ID3D12CommandQueue : public ID3D12Pageable {
    virtual void STDCALL UpdateTileMappings(ID3D12Resource*, u32, const D3D12_TILED_RESOURCE_COORDINATE*, const D3D12_TILE_REGION_SIZE*, ID3D12Heap*, u32, const D3D12_TILE_RANGE_FLAGS*, const u32*, const u32*, D3D12_TILE_MAPPING_FLAGS) = 0;
    virtual void STDCALL CopyTileMappings(ID3D12Resource*, const D3D12_TILED_RESOURCE_COORDINATE*, ID3D12Resource*, const D3D12_TILED_RESOURCE_COORDINATE*, const D3D12_TILE_REGION_SIZE*, D3D12_TILE_MAPPING_FLAGS) = 0;
    virtual void STDCALL ExecuteCommandLists(u32, ID3D12CommandList* const*) = 0;
    virtual void STDCALL SetMarker(u32, const void*, u32) = 0;
    virtual void STDCALL BeginEvent(u32, const void*, u32) = 0;
    virtual void STDCALL EndEvent() = 0;
    virtual i32 STDCALL Signal(ID3D12Fence*, u64) = 0;
    virtual i32 STDCALL Wait(ID3D12Fence*, u64) = 0;
    virtual i32 STDCALL GetTimestampFrequency(u64*) = 0;
    virtual i32 STDCALL GetClockCalibration(u64*, u64*) = 0;
    virtual D3D12_COMMAND_QUEUE_DESC STDCALL GetDesc() = 0;
};
struct ID3D12Device : public ID3D12Object {
    virtual u32 STDCALL GetNodeCount() = 0;
    virtual i32 STDCALL CreateCommandQueue(const D3D12_COMMAND_QUEUE_DESC*, const win_GUID&, void**) = 0;
    virtual i32 STDCALL CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE, const win_GUID&, void**) = 0;
    virtual i32 STDCALL CreateGraphicsPipelineState(const D3D12_GRAPHICS_PIPELINE_STATE_DESC*, const win_GUID&, void**) = 0;
    virtual i32 STDCALL CreateComputePipelineState(const D3D12_COMPUTE_PIPELINE_STATE_DESC*, const win_GUID&, void**) = 0;
    virtual i32 STDCALL CreateCommandList(u32, D3D12_COMMAND_LIST_TYPE, ID3D12CommandAllocator*, ID3D12PipelineState*, const win_GUID&, void**) = 0;
    virtual i32 STDCALL CheckFeatureSupport(D3D12_FEATURE, void*, u32) = 0;
    virtual i32 STDCALL CreateDescriptorHeap(const D3D12_DESCRIPTOR_HEAP_DESC*, const win_GUID&, void**) = 0;
    virtual u32 STDCALL GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE) = 0;
    virtual i32 STDCALL CreateRootSignature(u32, const void*, u64, const win_GUID&, void**) = 0;
    virtual void STDCALL CreateConstantBufferView(const D3D12_CONSTANT_BUFFER_VIEW_DESC*, D3D12_CPU_DESCRIPTOR_HANDLE) = 0;
    virtual void STDCALL CreateShaderResourceView(ID3D12Resource*, const D3D12_SHADER_RESOURCE_VIEW_DESC*, D3D12_CPU_DESCRIPTOR_HANDLE) = 0;
    virtual void STDCALL CreateUnorderedAccessView(ID3D12Resource*, ID3D12Resource*, const D3D12_UNORDERED_ACCESS_VIEW_DESC*, D3D12_CPU_DESCRIPTOR_HANDLE) = 0;
    virtual void STDCALL CreateRenderTargetView(ID3D12Resource*, const D3D12_RENDER_TARGET_VIEW_DESC*, D3D12_CPU_DESCRIPTOR_HANDLE) = 0;
    virtual void STDCALL CreateDepthStencilView(ID3D12Resource*, const D3D12_DEPTH_STENCIL_VIEW_DESC*, D3D12_CPU_DESCRIPTOR_HANDLE) = 0;
    virtual void STDCALL CreateSampler(const D3D12_SAMPLER_DESC*, D3D12_CPU_DESCRIPTOR_HANDLE) = 0;
    virtual void STDCALL CopyDescriptors(u32, const D3D12_CPU_DESCRIPTOR_HANDLE*, const u32*, u32, const D3D12_CPU_DESCRIPTOR_HANDLE*, const u32*, D3D12_DESCRIPTOR_HEAP_TYPE) = 0;
    virtual void STDCALL CopyDescriptorsSimple(u32, D3D12_CPU_DESCRIPTOR_HANDLE, D3D12_CPU_DESCRIPTOR_HANDLE, D3D12_DESCRIPTOR_HEAP_TYPE) = 0;
    virtual D3D12_RESOURCE_ALLOCATION_INFO* STDCALL GetResourceAllocationInfo(u32, u32, const D3D12_RESOURCE_DESC*, D3D12_RESOURCE_ALLOCATION_INFO*) = 0;
    virtual D3D12_HEAP_PROPERTIES* STDCALL GetCustomHeapProperties(u32, D3D12_HEAP_TYPE, D3D12_HEAP_PROPERTIES*) = 0;
    virtual i32 STDCALL CreateCommittedResource(const D3D12_HEAP_PROPERTIES*, D3D12_HEAP_FLAGS, const D3D12_RESOURCE_DESC*, D3D12_RESOURCE_STATES, const D3D12_CLEAR_VALUE*, const win_GUID&, void**) = 0;
    virtual i32 STDCALL CreateHeap(const D3D12_HEAP_DESC*, const win_GUID&, void**) = 0;
    virtual i32 STDCALL CreatePlacedResource(ID3D12Heap*, u64, const D3D12_RESOURCE_DESC*, D3D12_RESOURCE_STATES, const D3D12_CLEAR_VALUE*, const win_GUID&, void**) = 0;
    virtual i32 STDCALL CreateReservedResource(const D3D12_RESOURCE_DESC*, D3D12_RESOURCE_STATES, const D3D12_CLEAR_VALUE*, const win_GUID&, void**) = 0;
    virtual i32 STDCALL CreateSharedHandle(ID3D12DeviceChild*, const win_SECURITY_ATTRIBUTES*, u32 , u16*, void**) = 0;
    virtual i32 STDCALL OpenSharedHandle(void*, const win_GUID&, void**) = 0;
    virtual i32 STDCALL OpenSharedHandleByName(u16*, u32, void**) = 0;
    virtual i32 STDCALL MakeResident(u32, ID3D12Pageable* const*) = 0;
    virtual i32 STDCALL Evict(u32, ID3D12Pageable* const*) = 0;
    virtual i32 STDCALL CreateFence(u64, D3D12_FENCE_FLAGS, const win_GUID&, void**) = 0;
    virtual i32 STDCALL GetDeviceRemovedReason() = 0;
    virtual void STDCALL GetCopyableFootprints(const D3D12_RESOURCE_DESC*, u32, u32, u64, D3D12_PLACED_SUBRESOURCE_FOOTPRINT*, u32*, u64*, u64*) = 0;
    virtual i32 STDCALL CreateQueryHeap(const D3D12_QUERY_HEAP_DESC*, const win_GUID&, void**) = 0;
    virtual i32 STDCALL SetStablePowerState(i32) = 0;
    virtual i32 STDCALL CreateCommandSignature(const D3D12_COMMAND_SIGNATURE_DESC*, ID3D12RootSignature*, const win_GUID&, void**) = 0;
    virtual void STDCALL GetResourceTiling(ID3D12Resource*, u32*, D3D12_PACKED_MIP_INFO*, D3D12_TILE_SHAPE*, u32*, u32, D3D12_SUBRESOURCE_TILING*) = 0;
    virtual i64 STDCALL GetAdapterLuid() = 0;
};
struct ID3D12Debug : public IUnknown {
    virtual void STDCALL EnableDebugLayer() = 0;
};
struct DXGI_RGB {
    float Red;
    float Green;
    float Blue;
};
struct DXGI_RGBA {
    float Red;
    float Green;
    float Blue;
    float Alpha;
};
struct DXGI_GAMMA_CONTROL {
    DXGI_RGB Scale;
    DXGI_RGB Offset;
    DXGI_RGB GammaCurve[1025];
};
struct DXGI_GAMMA_CONTROL_CAPABILITIES {
    i32 ScaleAndOffsetSupported;
    float MaxConvertedValue;
    float MinConvertedValue;
    u32 NumGammaControlPoints;
    float ControlPointPositions[1025];
};
struct DXGI_RATIONAL {
    u32 Numerator;
    u32 Denominator;
};
enum DXGI_MODE_SCANLINE_ORDER {
    DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED = 0,
    DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE = 1,
    DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST = 2,
    DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST = 3
};
enum DXGI_MODE_SCALING {
    DXGI_MODE_SCALING_UNSPECIFIED = 0,
    DXGI_MODE_SCALING_CENTERED = 1,
    DXGI_MODE_SCALING_STRETCHED = 2
};
enum DXGI_MODE_ROTATION {
    DXGI_MODE_ROTATION_UNSPECIFIED = 0,
    DXGI_MODE_ROTATION_IDENTITY = 1,
    DXGI_MODE_ROTATION_ROTATE90 = 2,
    DXGI_MODE_ROTATION_ROTATE180 = 3,
    DXGI_MODE_ROTATION_ROTATE270 = 4
};
struct DXGI_MODE_DESC {
    u32 Width;
    u32 Height;
    DXGI_RATIONAL RefreshRate;
    DXGI_FORMAT Format;
    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
    DXGI_MODE_SCALING Scaling;
};
struct DXGI_OUTPUT_DESC {
    u16 DeviceName[32];
    D3D12_RECT DesktopCoordinates;
    i32 AttachedToDesktop;
    DXGI_MODE_ROTATION Rotation;
    void* Monitor;
};
struct DXGI_SURFACE_DESC {
    u32 Width;
    u32 Height;
    DXGI_FORMAT Format;
    DXGI_SAMPLE_DESC SampleDesc;
};
struct DXGI_MAPPED_RECT {
    i32 Pitch;
    u8* pBits;
};
struct DXGI_FRAME_STATISTICS {
    u32 PresentCount;
    u32 PresentRefreshCount;
    u32 SyncRefreshCount;
    i64 SyncQPCTime;
    i64 SyncGPUTime;
};
struct DXGI_ADAPTER_DESC {
    u16 Description[128];
    u32 VendorId;
    u32 DeviceId;
    u32 SubSysId;
    u32 Revision;
    u64 DedicatedVideoMemory;
    u64 DedicatedSystemMemory;
    u64 SharedSystemMemory;
    i64 AdapterLuid;
};
struct DXGI_ADAPTER_DESC1 {
    u16 Description[128];
    u32 VendorId;
    u32 DeviceId;
    u32 SubSysId;
    u32 Revision;
    u64 DedicatedVideoMemory;
    u64 DedicatedSystemMemory;
    u64 SharedSystemMemory;
    i64 AdapterLuid;
    u32 Flags;
};

#define DXGI_USAGE_SHADER_INPUT 0x00000010UL
#define DXGI_USAGE_RENDER_TARGET_OUTPUT 0x00000020UL
#define DXGI_USAGE_BACK_BUFFER 0x00000040UL
#define DXGI_USAGE_SHARED 0x00000080UL
#define DXGI_USAGE_READ_ONLY 0x00000100UL
#define DXGI_USAGE_DISCARD_ON_PRESENT 0x00000200UL
#define DXGI_USAGE_UNORDERED_ACCESS 0x00000400UL
typedef u32 DXGI_USAGE;

enum DXGI_SWAP_EFFECT {
    DXGI_SWAP_EFFECT_DISCARD = 0,
    DXGI_SWAP_EFFECT_SEQUENTIAL = 1,
    DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL = 3,
    DXGI_SWAP_EFFECT_FLIP_DISCARD = 4
};
struct DXGI_SWAP_CHAIN_DESC {
    DXGI_MODE_DESC BufferDesc;
    DXGI_SAMPLE_DESC SampleDesc;
    DXGI_USAGE BufferUsage;
    u32 BufferCount;
    void* OutputWindow;
    i32 Windowed;
    DXGI_SWAP_EFFECT SwapEffect;
    u32 Flags;
};
enum DXGI_SCALING {
    DXGI_SCALING_STRETCH = 0,
    DXGI_SCALING_NONE = 1,
    DXGI_SCALING_ASPECT_RATIO_STRETCH = 2
};
enum DXGI_ALPHA_MODE {
    DXGI_ALPHA_MODE_UNSPECIFIED = 0,
    DXGI_ALPHA_MODE_PREMULTIPLIED = 1,
    DXGI_ALPHA_MODE_STRAIGHT = 2,
    DXGI_ALPHA_MODE_IGNORE = 3,
    DXGI_ALPHA_MODE_FORCE_DWORD = 0xffffffff
};
struct DXGI_SWAP_CHAIN_DESC1 {
    u32 Width;
    u32 Height;
    DXGI_FORMAT Format;
    i32 Stereo;
    DXGI_SAMPLE_DESC SampleDesc;
    DXGI_USAGE BufferUsage;
    u32 BufferCount;
    DXGI_SCALING Scaling;
    DXGI_SWAP_EFFECT SwapEffect;
    DXGI_ALPHA_MODE AlphaMode;
    u32 Flags;
};
struct DXGI_SWAP_CHAIN_FULLSCREEN_DESC {
    DXGI_RATIONAL RefreshRate;
    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
    DXGI_MODE_SCALING Scaling;
    i32 Windowed;
};
struct DXGI_PRESENT_PARAMETERS {
    u32 DirtyRectsCount;
    D3D12_RECT* pDirtyRects;
    D3D12_RECT* pScrollRect;
    win_POINT* pScrollOffset;
};
struct DXGI_MATRIX_3X2_F {
    float _11;
    float _12;
    float _21;
    float _22;
    float _31;
    float _32;
};
enum DXGI_COLOR_SPACE_TYPE {
    DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709 = 0,
    DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709 = 1,
    DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P709 = 2,
    DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P2020 = 3,
    DXGI_COLOR_SPACE_RESERVED = 4,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601 = 5,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 = 6,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601 = 7,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 = 8,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709 = 9,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020 = 10,
    DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020 = 11,
    DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020 = 12,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_LEFT_P2020 = 13,
    DXGI_COLOR_SPACE_RGB_STUDIO_G2084_NONE_P2020 = 14,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_TOPLEFT_P2020 = 15,
    DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_TOPLEFT_P2020 = 16,
    DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P2020 = 17,
    DXGI_COLOR_SPACE_CUSTOM = 0xFFFFFFFF
};
struct IDXGIObject : public IUnknown {
    virtual i32 STDCALL SetPrivateData(const win_GUID&, u32, const void*) = 0;
    virtual i32 STDCALL SetPrivateDataInterface(const win_GUID&, const IUnknown*) = 0;
    virtual i32 STDCALL GetPrivateData(const win_GUID&, u32*, void*) = 0;
    virtual i32 STDCALL GetParent(const win_GUID&, void**) = 0;
};
struct IDXGIDeviceSubObject : public IDXGIObject {
    virtual i32 STDCALL GetDevice(const win_GUID&, void**) = 0;
};
struct IDXGISwapChain : public IDXGIDeviceSubObject {
    virtual i32 STDCALL Present(u32, u32) = 0;
    virtual i32 STDCALL GetBuffer(u32, const win_GUID&, void**) = 0;
    virtual i32 STDCALL SetFullscreenState(i32, IDXGIOutput*) = 0;
    virtual i32 STDCALL GetFullscreenState(i32*, IDXGIOutput**) = 0;
    virtual i32 STDCALL GetDesc(DXGI_SWAP_CHAIN_DESC*) = 0;
    virtual i32 STDCALL ResizeBuffers(u32, u32, u32, DXGI_FORMAT, u32) = 0;
    virtual i32 STDCALL ResizeTarget(const DXGI_MODE_DESC*) = 0;
    virtual i32 STDCALL GetContainingOutput(IDXGIOutput**) = 0;
    virtual i32 STDCALL GetFrameStatistics(DXGI_FRAME_STATISTICS*) = 0;
    virtual i32 STDCALL GetLastPresentCount(u32*) = 0;
};
struct IDXGISwapChain3 : public IDXGISwapChain {
    virtual i32 STDCALL GetDesc1(DXGI_SWAP_CHAIN_DESC1*) = 0;
    virtual i32 STDCALL GetFullscreenDesc(DXGI_SWAP_CHAIN_FULLSCREEN_DESC*) = 0;
    virtual i32 STDCALL GetHwnd(void**) = 0;
    virtual i32 STDCALL GetCoreWindow(const win_GUID&, void**) = 0;
    virtual i32 STDCALL Present1(u32, u32, const DXGI_PRESENT_PARAMETERS*) = 0;
    virtual i32 STDCALL IsTemporaryMonoSupported() = 0;
    virtual i32 STDCALL GetRestrictToOutput(IDXGIOutput**) = 0;
    virtual i32 STDCALL SetBackgroundColor(const DXGI_RGBA*) = 0;
    virtual i32 STDCALL GetBackgroundColor(DXGI_RGBA*) = 0;
    virtual i32 STDCALL SetRotation(DXGI_MODE_ROTATION) = 0;
    virtual i32 STDCALL GetRotation(DXGI_MODE_ROTATION*) = 0;
    virtual i32 STDCALL SetSourceSize(u32, u32) = 0;
    virtual i32 STDCALL GetSourceSize(u32*, u32*) = 0;
    virtual i32 STDCALL SetMaximumFrameLatency(u32) = 0;
    virtual i32 STDCALL GetMaximumFrameLatency(u32*) = 0;
    virtual void* STDCALL GetFrameLatencyWaitableObject() = 0;
    virtual i32 STDCALL SetMatrixTransform(const DXGI_MATRIX_3X2_F*) = 0;
    virtual i32 STDCALL GetMatrixTransform(DXGI_MATRIX_3X2_F*) = 0;
    virtual u32 STDCALL GetCurrentBackBufferIndex() = 0;
    virtual i32 STDCALL CheckColorSpaceSupport(DXGI_COLOR_SPACE_TYPE, u32*) = 0;
    virtual i32 STDCALL SetColorSpace1(DXGI_COLOR_SPACE_TYPE) = 0;
    virtual i32 STDCALL ResizeBuffers1(u32, u32, u32, DXGI_FORMAT, u32, const u32*, IUnknown* const*) = 0;
};
struct IDXGIFactory4 : public IDXGIObject {
    virtual i32 STDCALL EnumAdapters(u32, IDXGIAdapter**) = 0;
    virtual i32 STDCALL MakeWindowAssociation(void*, u32) = 0;
    virtual i32 STDCALL GetWindowAssociation(void**) = 0;
    virtual i32 STDCALL CreateSwapChain(IUnknown*, DXGI_SWAP_CHAIN_DESC*, IDXGISwapChain**) = 0;
    virtual i32 STDCALL CreateSoftwareAdapter(void*, IDXGIAdapter**) = 0;
    virtual i32 STDCALL EnumAdapters1(u32, IDXGIAdapter1**) = 0;
    virtual i32 STDCALL IsCurrent() = 0;
    virtual i32 STDCALL IsWindowedStereoEnabled() = 0;
    virtual i32 STDCALL CreateSwapChainForHwnd(IUnknown*, void*, const DXGI_SWAP_CHAIN_DESC1*, const DXGI_SWAP_CHAIN_FULLSCREEN_DESC*, IDXGIOutput*, IDXGISwapChain1**) = 0;
    virtual i32 STDCALL CreateSwapChainForCoreWindow(IUnknown*, IUnknown*, const DXGI_SWAP_CHAIN_DESC1*, IDXGIOutput*, IDXGISwapChain1**) = 0;
    virtual i32 STDCALL GetSharedResourceAdapterLuid(void*, i64*) = 0;
    virtual i32 STDCALL RegisterStereoStatusWindow(void*, u32, u32*) = 0;
    virtual i32 STDCALL RegisterStereoStatusEvent(void*, u32*) = 0;
    virtual void STDCALL UnregisterStereoStatus(u32) = 0;
    virtual i32 STDCALL RegisterOcclusionStatusWindow(void*, u32, u32*) = 0;
    virtual i32 STDCALL RegisterOcclusionStatusEvent(void*, u32*) = 0;
    virtual void STDCALL UnregisterOcclusionStatus(u32) = 0;
    virtual i32 STDCALL CreateSwapChainForComposition(IUnknown*, const DXGI_SWAP_CHAIN_DESC1*, IDXGIOutput*, IDXGISwapChain1**) = 0;
    virtual u32 STDCALL GetCreationFlags() = 0;
    virtual i32 STDCALL EnumAdapterByLuid(i64, const win_GUID&, void**) = 0;
    virtual i32 STDCALL EnumWarpAdapter(const win_GUID&, void**) = 0;
};

extern "C" void* STDCALL LoadLibraryA(const char*);
extern "C" void* STDCALL GetProcAddress(void*, const char*);

extern "C" { i32 _fltused; }

static void (STDCALLP win_OutputDebugString)(const char*);
static void* (STDCALLP win_GetModuleHandle)(const char*);
static void (STDCALLP win_Sleep)(u32);
static i32 (STDCALLP win_QueryPerformanceCounter)(i64*);
static i32 (STDCALLP win_QueryPerformanceFrequency)(i64*);
static void* (STDCALLP win_VirtualAlloc)(void*, u64, u32, u32);
static i32 (STDCALLP win_VirtualFree)(void*, u64, u32);
static void (STDCALLP win_ExitProcess)(u32);
static void* (STDCALLP win_CreateEventEx)(win_SECURITY_ATTRIBUTES*, const char*, u32, u32);
static u32 (STDCALLP win_WaitForSingleObject)(void*, u32);
static void* (STDCALLP win_CreateFile)(const char*, u32, u32, win_SECURITY_ATTRIBUTES*, u32, u32, void*);
static i32 (STDCALLP win_GetFileTime)(void*, u64*, u64*, u64*);
static i32 (STDCALLP win_AllocConsole)(void);
static i32 (STDCALLP win_WriteConsole)(void*, const void*, u32, u32*, void*);
static void* (STDCALLP win_GetStdHandle)(u32);

static i32 (STDCALLP win_PeekMessage)(win_MSG*, void*, u32, u32, u32);
static i64 (STDCALLP win_DispatchMessage)(const win_MSG*);
static void (STDCALLP win_PostQuitMessage)(i32);
static i64 (STDCALLP win_DefWindowProc)(void*, u32, u64, i64);
static void* (STDCALLP win_LoadCursor)(void*, const char*);
static i16 (STDCALLP win_RegisterClass)(const win_WNDCLASS*);
static void* (STDCALLP win_CreateWindowEx)(u32, const char*, const char*, u32, i32, i32, i32, i32, void*, void*, void*, void*);
static i32 (STDCALLP win_AdjustWindowRect)(win_RECT*, u32, i32);
static i32 (__cdecl* win_wsprintf)(char*, const char*, ...);
static i32 (STDCALLP win_SetWindowText)(void*, const char*);
static i32 (STDCALLP win_SetProcessDPIAware)(void);
static i32 (STDCALLP win_GetClientRect)(void*, win_RECT*);
static i16 (STDCALLP win_GetAsyncKeyState)(i32);

static i32 (STDCALLP win_CreateDXGIFactory1)(const win_GUID&, void**);

static i32 (STDCALLP D3D12CreateDevice)(IUnknown*, D3D_FEATURE_LEVEL, const win_GUID&, void**);
static i32 (STDCALLP D3D12GetDebugInterface)(const win_GUID&, void**);
static i32 (STDCALLP D3D12EnableExperimentalFeatures)(u32, const win_GUID&, void*, u32*);
#ifdef _DEVELOPMENT
struct D3D_SHADER_MACRO {
    const char* Name;
    const char* Definition;
};
i32 (STDCALLP D3DCompileFromFile)(const wchar_t*, const D3D_SHADER_MACRO*, void*, const char*, const char*, u32, u32, ID3DBlob**, ID3DBlob**);
#endif

static const win_GUID IID_ID3D12Debug = { 0x344488b7,0x6846,0x474b,0xb9,0x89,0xf0,0x27,0x44,0x82,0x45,0xe0 };
static const win_GUID IID_IDXGISwapChain = { 0x310d36a0,0xd2e7,0x4c0a,0xaa,0x04,0x6a,0x9d,0x23,0xb8,0x88,0x6a };
static const win_GUID IID_IDXGISwapChain3 = { 0x94d99bdb,0xf1f8,0x4ab0,0xb2,0x36,0x7d,0xa0,0x17,0x0e,0xda,0xb1 };
static const win_GUID IID_IDXGIFactory4 = { 0x1bc6ea02,0xef36,0x464f,0xbf,0x0c,0x21,0xca,0x39,0xe5,0x16,0x8a };
static const win_GUID IID_ID3D12GraphicsCommandList = { 0x5b160d0f,0xac1b,0x4185,0x8b,0xa8,0xb3,0xae,0x42,0xa5,0xa4,0x55 };
static const win_GUID IID_ID3D12CommandQueue = { 0x0ec870a6,0x5d7e,0x4c22,0x8c,0xfc,0x5b,0xaa,0xe0,0x76,0x16,0xed };
static const win_GUID IID_ID3D12Device = { 0x189819f1,0x1db6,0x4b57,0xbe,0x54,0x18,0x21,0x33,0x9b,0x85,0xf7 };
static const win_GUID IID_ID3D12DescriptorHeap = { 0x8efb471d,0x616c,0x4f49,0x90,0xf7,0x12,0x7b,0xb7,0x63,0xfa,0x51 };
static const win_GUID IID_ID3D12Resource = { 0x696442be,0xa72e,0x4059,0xbc,0x79,0x5b,0x5c,0x98,0x04,0x0f,0xad };
static const win_GUID IID_ID3D12RootSignature = { 0xc54a6b66,0x72df,0x4ee8,0x8b,0xe5,0xa9,0x46,0xa1,0x42,0x92,0x14 };
static const win_GUID IID_ID3D12CommandAllocator = { 0x6102dee4,0xaf59,0x4b09,0xb9,0x99,0xb4,0x4d,0x73,0xf0,0x9b,0x24 };
static const win_GUID IID_ID3D12Fence = { 0x0a753dcf,0xc4d8,0x4b91,0xad,0xf6,0xbe,0x5a,0x60,0xd9,0x5a,0x76 };
static const win_GUID IID_ID3D12PipelineState = { 0x765a30f3,0xf624,0x4c6f,0xa8,0x28,0xac,0xe9,0x48,0x62,0x24,0x45 };

#define VHR(r) if (r < 0) { Assert(0); }
#define SAFE_RELEASE(obj) if (obj) { (obj)->Release(); (obj) = nullptr; }

static struct
{
    u32 BackBufferResolution[2];
    u32 BackBufferIndex;
    u32 FrameIndex;
    u32 DescriptorSize;
    u32 RTVDescriptorSize;
    D3D12_CPU_DESCRIPTOR_HANDLE RTVHeapStart;
    D3D12_CPU_DESCRIPTOR_HANDLE DSVHeapStart;
    ID3D12Device* Device;
    ID3D12CommandQueue* CmdQueue;
    ID3D12CommandAllocator* CmdAlloc[2];
    ID3D12GraphicsCommandList* CmdList;
    ID3D12Resource* SwapBuffers[4];
    ID3D12Resource* DepthStencilImage;
    IDXGIFactory4* GiFactory;
    IDXGISwapChain3* SwapChain;
    ID3D12DescriptorHeap* RTVHeap;
    ID3D12DescriptorHeap* DSVHeap;
    u64 CPUCompletedFrames;
    ID3D12Fence* FrameFence;
    void* FrameFenceEvent;
    D3D12_VIEWPORT Viewport;
    D3D12_RECT Scissor;
    i64 Frequency;
    i64 StartCounter;
    void* Window;
    double FrameTime;
    float FrameDeltaTime;
} G;

struct FEngine0
{
    ID3D12PipelineState* DisplayPSO;
    ID3D12RootSignature* DisplayRS;
    const char* VSDefine;
    const char* PSDefine;
};

static double GetTime()
{
    i64 Counter;
    win_QueryPerformanceCounter(&Counter);
    return (Counter - G.StartCounter) / (double)G.Frequency;
}

static i64 STDCALL ProcessWindowMessage(void* Window, u32 Message, u64 WParam, i64 LParam)
{
    switch (Message)
    {
        case win_WM_KEYDOWN:
            if (WParam == win_VK_ESCAPE)
            {
                win_PostQuitMessage(0);
                return 0;
            }
            break;
        case win_WM_DESTROY:
            win_PostQuitMessage(0);
            return 0;
    }
    return win_DefWindowProc(Window, Message, WParam, LParam);
}

static void* CreateWindow(u32 ResX, u32 ResY)
{
    win_WNDCLASS Winclass = {};
    Winclass.lpfnWndProc = ProcessWindowMessage;
    Winclass.hInstance = win_GetModuleHandle(nullptr);
    Winclass.hCursor = win_LoadCursor(nullptr, win_IDC_ARROW);
    Winclass.lpszClassName = "eneida";
    if (!win_RegisterClass(&Winclass))
    {
        Assert(0);
    }

    win_RECT Rect = { 0, 0, (i32)ResX, (i32)ResY };
    if (!win_AdjustWindowRect(&Rect, win_WS_OVERLAPPED | win_WS_SYSMENU | win_WS_CAPTION | win_WS_MINIMIZEBOX, 0))
    {
        Assert(0);
    }

    void* Window = win_CreateWindowEx(
            0, "eneida", "eneida",
            win_WS_OVERLAPPED | win_WS_SYSMENU | win_WS_CAPTION | win_WS_MINIMIZEBOX | win_WS_VISIBLE,
            win_CW_USEDEFAULT, win_CW_USEDEFAULT,
            Rect.right - Rect.left, Rect.bottom - Rect.top,
            nullptr, nullptr, nullptr, 0);
    Assert(Window);
    return Window;
}

static void UpdateFrameTime()
{
    static double PrevTime = -1.0;
    static double PrevFPSTime = 0.0;
    static u32 FPSFrame = 0;

    if (PrevTime < 0.0)
    {
        PrevTime = GetTime();
        PrevFPSTime = PrevTime;
    }

    G.FrameTime = GetTime();
    G.FrameDeltaTime = (float)(G.FrameTime - PrevTime);
    PrevTime = G.FrameTime;

    if ((G.FrameTime - PrevFPSTime) >= 1.0)
    {
        double FPS = FPSFrame / (G.FrameTime - PrevFPSTime);
        double MicroSeconds = (1.0 / FPS) * 1000000.0;
        char Text[256];
        win_wsprintf(Text, "[%d fps  %d us] %s", (i32)FPS, (i32)MicroSeconds, "eneida");
        win_SetWindowText(G.Window, Text);
        PrevFPSTime = G.FrameTime;
        FPSFrame = 0;
    }
    FPSFrame++;
}

static void Present()
{
    Assert(G.CmdQueue);

    G.SwapChain->Present(0, 0);
    G.CmdQueue->Signal(G.FrameFence, ++G.CPUCompletedFrames);

    const u64 GPUCompletedFrames = G.FrameFence->GetCompletedValue();

    if ((G.CPUCompletedFrames - GPUCompletedFrames) >= 2)
    {
        G.FrameFence->SetEventOnCompletion(GPUCompletedFrames + 1, G.FrameFenceEvent);
        win_WaitForSingleObject(G.FrameFenceEvent, win_INFINITE);
    }

    G.BackBufferIndex = G.SwapChain->GetCurrentBackBufferIndex();
    G.FrameIndex = !G.FrameIndex;
}

static bool InitializeD3D12()
{
    Assert(G.Device == nullptr);
    Assert(G.Window != nullptr);

    VHR(win_CreateDXGIFactory1(IID_IDXGIFactory4, (void**)&G.GiFactory));

#ifdef _DEBUG
    ID3D12Debug* Dbg = nullptr;
    D3D12GetDebugInterface(IID_ID3D12Debug, (void**)&Dbg);
    if (Dbg)
    {
        Dbg->EnableDebugLayer();
        Dbg->Release();
    }
#endif
    if (D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_12_0, IID_ID3D12Device, (void**)&G.Device) != 0)
    {
        return false;
    }

    D3D12_COMMAND_QUEUE_DESC CmdQueueDesc = {};
    CmdQueueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
    CmdQueueDesc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
    CmdQueueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
    VHR(G.Device->CreateCommandQueue(&CmdQueueDesc, IID_ID3D12CommandQueue, (void**)&G.CmdQueue));

    DXGI_SWAP_CHAIN_DESC SwapChainDesc = {};
    SwapChainDesc.BufferCount = 4;
    SwapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    SwapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    SwapChainDesc.OutputWindow = G.Window;
    SwapChainDesc.SampleDesc.Count = 1;
    SwapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
    SwapChainDesc.Windowed = 1;
    IDXGISwapChain* TempSwapChain;
    VHR(G.GiFactory->CreateSwapChain(G.CmdQueue, &SwapChainDesc, &TempSwapChain));
    VHR(TempSwapChain->QueryInterface(IID_IDXGISwapChain3, (void**)&G.SwapChain));
    TempSwapChain->Release();

    for (u32 Idx = 0; Idx < 2; ++Idx)
    {
        VHR(G.Device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_ID3D12CommandAllocator, (void**)&G.CmdAlloc[Idx]));
    }

    win_RECT Rect;
    win_GetClientRect(G.Window, &Rect);
    G.BackBufferResolution[0] = (u32)(Rect.right - Rect.left);
    G.BackBufferResolution[1] = (u32)(Rect.bottom - Rect.top);

    G.DescriptorSize = G.Device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
    G.RTVDescriptorSize = G.Device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

    // RTV descriptor heap
    {
        D3D12_DESCRIPTOR_HEAP_DESC HeapDesc = {};
        HeapDesc.NumDescriptors = 4;
        HeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
        HeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
        VHR(G.Device->CreateDescriptorHeap(&HeapDesc, IID_ID3D12DescriptorHeap, (void**)&G.RTVHeap));
        G.RTVHeapStart = G.RTVHeap->GetCPUDescriptorHandleForHeapStart();

        D3D12_CPU_DESCRIPTOR_HANDLE Handle = G.RTVHeapStart;

        for (u32 Idx = 0; Idx < 4; ++Idx)
        {
            VHR(G.SwapChain->GetBuffer(Idx, IID_ID3D12Resource, (void**)&G.SwapBuffers[Idx]));

            G.Device->CreateRenderTargetView(G.SwapBuffers[Idx], nullptr, Handle);
            Handle.ptr += G.RTVDescriptorSize;
        }
    }
    // depth-stencil image, view and heap
    {
        D3D12_DESCRIPTOR_HEAP_DESC HeapDesc = {};
        HeapDesc.NumDescriptors = 1;
        HeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
        HeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
        VHR(G.Device->CreateDescriptorHeap(&HeapDesc, IID_ID3D12DescriptorHeap, (void**)&G.DSVHeap));
        G.DSVHeapStart = G.DSVHeap->GetCPUDescriptorHandleForHeapStart();

        D3D12_CLEAR_VALUE ClearValue = {};
        ClearValue.Format = DXGI_FORMAT_D32_FLOAT;
        ClearValue.DepthStencil.Depth = 1.0f;
        ClearValue.DepthStencil.Stencil = 0;

        D3D12_HEAP_PROPERTIES HeapProps = {};
        HeapProps.Type = D3D12_HEAP_TYPE_DEFAULT;

        D3D12_RESOURCE_DESC ImageDesc = {};
        ImageDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
        ImageDesc.Width = G.BackBufferResolution[0];
        ImageDesc.Height = G.BackBufferResolution[1];
        ImageDesc.DepthOrArraySize = 1;
        ImageDesc.MipLevels = 1;
        ImageDesc.Format = DXGI_FORMAT_D32_FLOAT;
        ImageDesc.SampleDesc.Count = 1;
        ImageDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
        ImageDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
        VHR(G.Device->CreateCommittedResource(&HeapProps, D3D12_HEAP_FLAG_NONE, &ImageDesc,
                    D3D12_RESOURCE_STATE_DEPTH_WRITE, &ClearValue, IID_ID3D12Resource, (void**)&G.DepthStencilImage));

        D3D12_DEPTH_STENCIL_VIEW_DESC ViewDesc = {};
        ViewDesc.Format = DXGI_FORMAT_D32_FLOAT;
        ViewDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
        ViewDesc.Flags = D3D12_DSV_FLAG_NONE;
        G.Device->CreateDepthStencilView(G.DepthStencilImage, &ViewDesc, G.DSVHeapStart);
    }
    VHR(G.Device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_ID3D12Fence, (void**)&G.FrameFence));

    G.FrameFenceEvent = win_CreateEventEx(nullptr, nullptr, 0, win_EVENT_ALL_ACCESS);
    Assert(G.FrameFenceEvent != nullptr);

    VHR(G.Device->CreateCommandList(1, D3D12_COMMAND_LIST_TYPE_DIRECT, G.CmdAlloc[0], nullptr,
                IID_ID3D12GraphicsCommandList, (void**)&G.CmdList));
    G.CmdList->Close();

    G.Viewport = { 0.0f, 0.0f, (float)G.BackBufferResolution[0], (float)G.BackBufferResolution[1], 0.0f, 1.0f };
    G.Scissor = { 0, 0, (i32)G.BackBufferResolution[0], (i32)G.BackBufferResolution[1] };

    return true;
}

static void ShutdownD3D12()
{
}

static void UpdateShaders(void* EnginePtr, void (*RebuildShaders)(void* EnginePtr))
{
    static double PrevCompilation;

    if (PrevCompilation == 0.0)
    {
        PrevCompilation = GetTime();
    }
    else if (win_GetAsyncKeyState(win_VK_CONTROL) && win_GetAsyncKeyState('S') && (GetTime() - PrevCompilation) > 0.25)
    {
        win_Sleep(50);
        RebuildShaders(EnginePtr);
        PrevCompilation = GetTime();
    }
}

static void E0_CreateShaders(void* EnginePtr)
{
    FEngine0& E0 = *(FEngine0*)EnginePtr;

    // TODO: Implement non-development path
#ifdef _DEVELOPMENT
    Assert(E0.VSDefine);
    Assert(E0.PSDefine);
    ID3DBlob* VSBytecode;
    ID3DBlob* PSBytecode;
    ID3DBlob* Errors;
    D3D_SHADER_MACRO VSMacros[] = { { E0.VSDefine, "1" }, { nullptr, nullptr } };
    D3D_SHADER_MACRO PSMacros[] = { { E0.PSDefine, "1" }, { nullptr, nullptr } };
    i32 Res = D3DCompileFromFile(L"eneida.hlsl", VSMacros, nullptr, "VSFullTriangle", "vs_5_1", 0, 0, &VSBytecode, &Errors);
    if (Res != 0)
    {
        if (Errors)
        {
            win_WriteConsole(win_GetStdHandle((u32)-11), Errors->GetBufferPointer(),
                    (u32)Errors->GetBufferSize() - 1, nullptr, nullptr);
        }
        return;
    }
    Res = D3DCompileFromFile(L"eneida.hlsl", PSMacros, nullptr, "PSDisplay", "ps_5_1", 0, 0, &PSBytecode, &Errors);
    if (Res != 0)
    {
        if (Errors)
        {
            win_WriteConsole(win_GetStdHandle((u32)-11), Errors->GetBufferPointer(),
                    (u32)Errors->GetBufferSize() - 1, nullptr, nullptr);
        }
        return;
    }

    SAFE_RELEASE(E0.DisplayPSO);
    SAFE_RELEASE(E0.DisplayRS);
    D3D12_GRAPHICS_PIPELINE_STATE_DESC PSODesc = {};
    PSODesc.VS = { VSBytecode->GetBufferPointer(), VSBytecode->GetBufferSize() };
    PSODesc.PS = { PSBytecode->GetBufferPointer(), PSBytecode->GetBufferSize() };
    PSODesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID;
    PSODesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
    PSODesc.BlendState.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
    PSODesc.SampleMask = 0xffffffff;
    PSODesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
    PSODesc.NumRenderTargets = 1;
    PSODesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
    PSODesc.SampleDesc.Count = 1;

    VHR(G.Device->CreateGraphicsPipelineState(&PSODesc, IID_ID3D12PipelineState, (void**)&E0.DisplayPSO));
    VHR(G.Device->CreateRootSignature(0, VSBytecode->GetBufferPointer(), VSBytecode->GetBufferSize(),
                IID_ID3D12RootSignature, (void**)&E0.DisplayRS));
    SAFE_RELEASE(VSBytecode);
    SAFE_RELEASE(PSBytecode);
#endif
}

static void E0_Update(FEngine0& E0)
{
#ifdef _DEVELOPMENT
    UpdateShaders(&E0, E0_CreateShaders);
#endif

    ID3D12CommandAllocator* CmdAlloc = G.CmdAlloc[G.FrameIndex];
    CmdAlloc->Reset();

    ID3D12GraphicsCommandList* CmdList = G.CmdList;

    D3D12_RESOURCE_BARRIER Barrier = {};
    Barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    Barrier.Transition.pResource = G.SwapBuffers[G.BackBufferIndex];
    Barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
    Barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;

    D3D12_CPU_DESCRIPTOR_HANDLE RTVHandle = G.RTVHeapStart;
    RTVHandle.ptr += G.BackBufferIndex * G.RTVDescriptorSize;

    const float ClearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };

    CmdList->Reset(CmdAlloc, nullptr);
    CmdList->RSSetViewports(1, &G.Viewport);
    CmdList->RSSetScissorRects(1, &G.Scissor);
    CmdList->ResourceBarrier(1, &Barrier);
    CmdList->OMSetRenderTargets(1, &RTVHandle, 0, &G.DSVHeapStart);
    CmdList->ClearRenderTargetView(RTVHandle, ClearColor, 0, nullptr);
    CmdList->ClearDepthStencilView(G.DSVHeapStart, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
    CmdList->SetPipelineState(E0.DisplayPSO);
    CmdList->SetGraphicsRootSignature(E0.DisplayRS);
    CmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    CmdList->DrawInstanced(3, 1, 0, 0);

    Barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
    Barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
    CmdList->ResourceBarrier(1, &Barrier);
    CmdList->Close();

    G.CmdQueue->ExecuteCommandLists(1, (ID3D12CommandList**)&CmdList);
}

static i32 E0_Run(FEngine0& E0)
{
    E0.VSDefine = "VS_FULL_TRIANGLE";
    E0.PSDefine = "PS_DISPLAY";
    E0_CreateShaders(&E0);

    for (;;)
    {
        win_MSG Message = {};
        if (win_PeekMessage(&Message, 0, 0, 0, win_PM_REMOVE))
        {
            win_DispatchMessage(&Message);
            if (Message.message == win_WM_QUIT)
            {
                break;
            }
        }
        else
        {
            UpdateFrameTime();
            E0_Update(E0);
            Present();
        }
    }

    SAFE_RELEASE(E0.DisplayPSO);
    SAFE_RELEASE(E0.DisplayRS);
    return 0;
}

void Start()
{
    void* Kernel32DLL = LoadLibraryA("kernel32.dll");
    win_OutputDebugString = (decltype(win_OutputDebugString))GetProcAddress(Kernel32DLL, "OutputDebugStringA");
    win_GetModuleHandle = (decltype(win_GetModuleHandle))GetProcAddress(Kernel32DLL, "GetModuleHandleA");
    win_Sleep = (decltype(win_Sleep))GetProcAddress(Kernel32DLL, "Sleep");
    win_QueryPerformanceCounter = (decltype(win_QueryPerformanceCounter))GetProcAddress(Kernel32DLL, "QueryPerformanceCounter");
    win_QueryPerformanceFrequency = (decltype(win_QueryPerformanceFrequency))GetProcAddress(Kernel32DLL, "QueryPerformanceFrequency");
    win_VirtualAlloc = (decltype(win_VirtualAlloc))GetProcAddress(Kernel32DLL, "VirtualAlloc");
    win_VirtualFree = (decltype(win_VirtualFree))GetProcAddress(Kernel32DLL, "VirtualFree");
    win_ExitProcess = (decltype(win_ExitProcess))GetProcAddress(Kernel32DLL, "ExitProcess");
    win_CreateEventEx = (decltype(win_CreateEventEx))GetProcAddress(Kernel32DLL, "CreateEventExA");
    win_WaitForSingleObject = (decltype(win_WaitForSingleObject))GetProcAddress(Kernel32DLL, "WaitForSingleObject");
    win_CreateFile = (decltype(win_CreateFile))GetProcAddress(Kernel32DLL, "CreateFileA");
    win_GetFileTime = (decltype(win_GetFileTime))GetProcAddress(Kernel32DLL, "GetFileTime");
    win_AllocConsole = (decltype(win_AllocConsole))GetProcAddress(Kernel32DLL, "AllocConsole");
    win_WriteConsole = (decltype(win_WriteConsole))GetProcAddress(Kernel32DLL, "WriteConsoleA");
    win_GetStdHandle = (decltype(win_GetStdHandle))GetProcAddress(Kernel32DLL, "GetStdHandle");

    void* User32DLL = LoadLibraryA("user32.dll");
    win_PeekMessage = (decltype(win_PeekMessage))GetProcAddress(User32DLL, "PeekMessageA");
    win_DispatchMessage = (decltype(win_DispatchMessage))GetProcAddress(User32DLL, "DispatchMessageA");
    win_PostQuitMessage = (decltype(win_PostQuitMessage))GetProcAddress(User32DLL, "PostQuitMessage");
    win_DefWindowProc = (decltype(win_DefWindowProc))GetProcAddress(User32DLL, "DefWindowProcA");
    win_LoadCursor = (decltype(win_LoadCursor))GetProcAddress(User32DLL, "LoadCursorA");
    win_RegisterClass = (decltype(win_RegisterClass))GetProcAddress(User32DLL, "RegisterClassA");
    win_CreateWindowEx = (decltype(win_CreateWindowEx))GetProcAddress(User32DLL, "CreateWindowExA");
    win_AdjustWindowRect = (decltype(win_AdjustWindowRect))GetProcAddress(User32DLL, "AdjustWindowRect");
    win_wsprintf = (decltype(win_wsprintf))GetProcAddress(User32DLL, "wsprintfA");
    win_SetWindowText = (decltype(win_SetWindowText))GetProcAddress(User32DLL, "SetWindowTextA");
    win_SetProcessDPIAware = (decltype(win_SetProcessDPIAware))GetProcAddress(User32DLL, "SetProcessDPIAware");
    win_GetClientRect = (decltype(win_GetClientRect))GetProcAddress(User32DLL, "GetClientRect");
    win_GetAsyncKeyState = (decltype(win_GetAsyncKeyState))GetProcAddress(User32DLL, "GetAsyncKeyState");

    void* D3D12DLL = LoadLibraryA("d3d12.dll");
    if (!D3D12DLL)
    {
        // TODO: Add MessageBox
        win_ExitProcess(255);
    }
    D3D12CreateDevice = (decltype(D3D12CreateDevice))GetProcAddress(D3D12DLL, "D3D12CreateDevice");
    D3D12GetDebugInterface = (decltype(D3D12GetDebugInterface))GetProcAddress(D3D12DLL, "D3D12GetDebugInterface");

    void* DXGIDLL = LoadLibraryA("dxgi.dll");
    win_CreateDXGIFactory1 = (decltype(win_CreateDXGIFactory1))GetProcAddress(DXGIDLL, "CreateDXGIFactory1");

#ifdef _DEVELOPMENT
    void* DXCompilerDLL = LoadLibraryA("compilers/d3dcompiler_47.dll");
    Assert(DXCompilerDLL);
    D3DCompileFromFile = (decltype(D3DCompileFromFile))GetProcAddress(DXCompilerDLL, "D3DCompileFromFile");
    Assert(D3DCompileFromFile);
    win_AllocConsole();
#endif

    win_QueryPerformanceCounter(&G.StartCounter);
    win_QueryPerformanceFrequency(&G.Frequency);
    win_SetProcessDPIAware();

    G.Window = CreateWindow(1280, 720);

    if (!InitializeD3D12())
    {
        // TODO: Add MessageBox
        win_ExitProcess(255);
    }

    FEngine0 Engine = {};
    E0_Run(Engine);

    ShutdownD3D12();
    win_ExitProcess(0);
}
